var documenterSearchIndex = {"docs":
[{"location":"basics/NonlinearSolution/#Nonlinear-Solutions","page":"Nonlinear Solutions","title":"Nonlinear Solutions","text":"","category":"section"},{"location":"basics/NonlinearSolution/","page":"Nonlinear Solutions","title":"Nonlinear Solutions","text":"SciMLBase.NonlinearSolution","category":"page"},{"location":"basics/NonlinearSolution/#SciMLBase.NonlinearSolution","page":"Nonlinear Solutions","title":"SciMLBase.NonlinearSolution","text":"struct NonlinearSolution{T, N, uType, R, P, A, O, uType2} <: SciMLBase.AbstractNonlinearSolution{T, N}\n\nRepresentation of the solution to a nonlinear equation defined by a NonlinearProblem, or the steady state solution to a differential equation defined by a SteadyStateProblem.\n\nFields\n\nu: the representation of the nonlinear equation's solution.\nresid: the residual of the solution.\nprob: the original NonlinearProblem/SteadyStateProblem that was solved.\nalg: the algorithm type used by the solver.\noriginal: if the solver is wrapped from an alternative solver ecosystem, such as NLsolve.jl, then this is the original return from said solver library.\nretcode: the return code from the solver. Used to determine whether the solver solved successfully or whether it exited due to an error. For more details, see  the return code documentation.\nleft: if the solver is bracketing method, this is the final left bracket value.\nright: if the solver is bracketing method, this is the final right bracket value.\n\n\n\n\n\n","category":"type"},{"location":"basics/FAQ/#Frequently-Asked-Questions","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"basics/FAQ/#How-is-the-performance-of-Julia's-NonlinearSolve.jl-vs-MATLAB's-fzero?","page":"Frequently Asked Questions","title":"How is the performance of Julia's NonlinearSolve.jl vs MATLAB's fzero?","text":"","category":"section"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"This is addressed in a Twitter thread with the author of the improved fzero. On the test example:","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"using NonlinearSolve, BenchmarkTools\n\nN = 100_000;\nlevels = 1.5 .* rand(N);\nout = zeros(N);\nmyfun(x, lv) = x * sin(x) - lv\n\nfunction f(out, levels, u0)\n    for i in 1:N\n        out[i] = solve(IntervalNonlinearProblem{false}(IntervalNonlinearFunction{false}(myfun),\n                                                       u0, levels[i]), Falsi()).u\n    end\nend\n\nfunction f2(out, levels, u0)\n    for i in 1:N\n        out[i] = solve(NonlinearProblem{false}(NonlinearFunction{false}(myfun),\n                                               u0, levels[i]), SimpleNewtonRaphson()).u\n    end\nend\n\n@btime f(out, levels, (0.0, 2.0))\n@btime f2(out, levels, 1.0)","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"MATLAB 2022a achieves 1.66s. Try this code yourself: we receive 0.06 seconds, or a 28x speedup. This example is still not optimized in the Julia code, and we expect an improvement in a near future version.","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"For more information on performance of SciML, see the SciMLBenchmarks.","category":"page"},{"location":"basics/NonlinearFunctions/#nonlinearfunctions","page":"NonlinearFunctions and Jacobian Types","title":"NonlinearFunctions and Jacobian Types","text":"","category":"section"},{"location":"basics/NonlinearFunctions/","page":"NonlinearFunctions and Jacobian Types","title":"NonlinearFunctions and Jacobian Types","text":"The SciML ecosystem provides an extensive interface for declaring extra functions associated with the differential equation's data. In traditional libraries, there is usually only one option: the Jacobian. However, we allow for a large array of pre-computed functions to speed up the calculations. This is offered via the NonlinearFunction types, which can be passed to the problems.","category":"page"},{"location":"basics/NonlinearFunctions/#Function-Type-Definitions","page":"NonlinearFunctions and Jacobian Types","title":"Function Type Definitions","text":"","category":"section"},{"location":"basics/NonlinearFunctions/","page":"NonlinearFunctions and Jacobian Types","title":"NonlinearFunctions and Jacobian Types","text":"SciMLBase.IntervalNonlinearFunction\nSciMLBase.NonlinearFunction","category":"page"},{"location":"basics/NonlinearFunctions/#SciMLBase.IntervalNonlinearFunction","page":"NonlinearFunctions and Jacobian Types","title":"SciMLBase.IntervalNonlinearFunction","text":"IntervalNonlinearFunction{iip, specialize, F, Ta, S, S2, O, SYS} <: AbstractIntervalNonlinearFunction{iip,specialize}\n\nA representation of an interval nonlinear system of equations f, defined by:\n\nf(tp) = u = 0\n\nand all of its related functions. For all cases, p are the parameters and t is the interval variable.\n\nConstructor\n\nIntervalNonlinearFunction{iip, specialize}(f;\n                           analytic = __has_analytic(f) ? f.analytic : nothing,\n                           syms = __has_syms(f) ? f.syms : nothing,\n                           paramsyms = __has_paramsyms(f) ? f.paramsyms : nothing,\n                           sys = __has_sys(f) ? f.sys : nothing)\n\nNote that only the function f itself is required. This function should be given as f!(u,t,p) or u = f(t,p). See the section on iip for more details on in-place vs out-of-place handling.\n\nAll of the remaining functions are optional for improving or accelerating the usage of f. These include:\n\nanalytic(p): used to pass an analytical solution function for the analytical solution of the ODE. Generally only used for testing and development of the solvers.\nsyms: the symbol names for the elements of the equation. This should match u0 in size. For example, if u0 = [0.0,1.0] and syms = [:x, :y], this will apply a canonical naming to the values, allowing sol[:x] in the solution and automatically naming values in plots.\nparamsyms: the symbol names for the parameters of the equation. This should match p in size. For example, if p = [0.0, 1.0] and paramsyms = [:a, :b], this will apply a canonical naming to the values, allowing sol[:a] in the solution.\n\niip: In-Place vs Out-Of-Place\n\nFor more details on this argument, see the ODEFunction documentation.\n\nspecialize: Controlling Compilation and Specialization\n\nFor more details on this argument, see the ODEFunction documentation.\n\nFields\n\nThe fields of the IntervalNonlinearFunction type directly match the names of the inputs.\n\n\n\n","category":"type"},{"location":"basics/NonlinearFunctions/#SciMLBase.NonlinearFunction","page":"NonlinearFunctions and Jacobian Types","title":"SciMLBase.NonlinearFunction","text":"NonlinearFunction{iip,F,TMM,Ta,Tt,TJ,JVP,VJP,JP,SP,TW,TWt,TPJ,S,S2,O,TCV} <: AbstractNonlinearFunction{iip,specialize}\n\nA representation of a nonlinear system of equations f, defined by:\n\n0 = f(up)\n\nand all of its related functions, such as the Jacobian of f, its gradient with respect to time, and more. For all cases, u0 is the initial condition, p are the parameters, and t is the independent variable.\n\nConstructor\n\nNonlinearFunction{iip, specialize}(f;\n                           analytic = __has_analytic(f) ? f.analytic : nothing,\n                           jac = __has_jac(f) ? f.jac : nothing,\n                           jvp = __has_jvp(f) ? f.jvp : nothing,\n                           vjp = __has_vjp(f) ? f.vjp : nothing,\n                           jac_prototype = __has_jac_prototype(f) ? f.jac_prototype : nothing,\n                           sparsity = __has_sparsity(f) ? f.sparsity : jac_prototype,\n                           paramjac = __has_paramjac(f) ? f.paramjac : nothing,\n                           syms = __has_syms(f) ? f.syms : nothing,\n                           paramsyms = __has_paramsyms(f) ? f.paramsyms : nothing,\n                           colorvec = __has_colorvec(f) ? f.colorvec : nothing,\n                           sys = __has_sys(f) ? f.sys : nothing)\n\nNote that only the function f itself is required. This function should be given as f!(du,u,p) or du = f(u,p). See the section on iip for more details on in-place vs out-of-place handling.\n\nAll of the remaining functions are optional for improving or accelerating the usage of f. These include:\n\nanalytic(u0,p): used to pass an analytical solution function for the analytical solution of the ODE. Generally only used for testing and development of the solvers.\njac(J,u,p) or J=jac(u,p): returns fracdfdu\njvp(Jv,v,u,p) or Jv=jvp(v,u,p): returns the directional derivativefracdfdu v\nvjp(Jv,v,u,p) or Jv=vjp(v,u,p): returns the adjoint derivativefracdfdu^ast v\njac_prototype: a prototype matrix matching the type that matches the Jacobian. For example, if the Jacobian is tridiagonal, then an appropriately sized Tridiagonal matrix can be used as the prototype and integrators will specialize on this structure where possible. Non-structured sparsity patterns should use a SparseMatrixCSC with a correct sparsity pattern for the Jacobian. The default is nothing, which means a dense Jacobian.\nparamjac(pJ,u,p): returns the parameter Jacobian fracdfdp.\nsyms: the symbol names for the elements of the equation. This should match u0 in size. For example, if u0 = [0.0,1.0] and syms = [:x, :y], this will apply a canonical naming to the values, allowing sol[:x] in the solution and automatically naming values in plots.\nparamsyms: the symbol names for the parameters of the equation. This should match p in size. For example, if p = [0.0, 1.0] and paramsyms = [:a, :b], this will apply a canonical naming to the values, allowing sol[:a] in the solution.\ncolorvec: a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the jac_prototype. This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern. Defaults to nothing, which means a color vector will be internally computed on demand when required. The cost of this operation is highly dependent on the sparsity pattern.\n\niip: In-Place vs Out-Of-Place\n\nFor more details on this argument, see the ODEFunction documentation.\n\nspecialize: Controlling Compilation and Specialization\n\nFor more details on this argument, see the ODEFunction documentation.\n\nFields\n\nThe fields of the NonlinearFunction type directly match the names of the inputs.\n\n\n\n","category":"type"},{"location":"api/simplenonlinearsolve/#SimpleNonlinearSolve.jl","page":"SimpleNonlinearSolve.jl","title":"SimpleNonlinearSolve.jl","text":"","category":"section"},{"location":"api/simplenonlinearsolve/","page":"SimpleNonlinearSolve.jl","title":"SimpleNonlinearSolve.jl","text":"These methods can be used independently of the rest of NonlinearSolve.jl","category":"page"},{"location":"api/simplenonlinearsolve/#Solver-API","page":"SimpleNonlinearSolve.jl","title":"Solver API","text":"","category":"section"},{"location":"api/simplenonlinearsolve/","page":"SimpleNonlinearSolve.jl","title":"SimpleNonlinearSolve.jl","text":"Bisection\nFalsi\nSimpleNewtonRaphson\nBroyden\nKlement\nSimpleTrustRegion\nRidder\nBrent\nSimpleDFSane","category":"page"},{"location":"api/simplenonlinearsolve/#SimpleNonlinearSolve.Bisection","page":"SimpleNonlinearSolve.jl","title":"SimpleNonlinearSolve.Bisection","text":"Bisection(; exact_left = false, exact_right = false)\n\nA common bisection method.\n\nKeyword Arguments\n\nexact_left: whether to enforce whether the left side of the interval must be exactly zero for the returned result. Defaults to false.\nexact_right: whether to enforce whether the right side of the interval must be exactly zero for the returned result. Defaults to false.\n\n\n\n\n\n","category":"type"},{"location":"api/simplenonlinearsolve/#SimpleNonlinearSolve.Falsi","page":"SimpleNonlinearSolve.jl","title":"SimpleNonlinearSolve.Falsi","text":"Falsi: A non-allocating regula falsi method\n\n\n\n\n\n","category":"type"},{"location":"api/simplenonlinearsolve/#SimpleNonlinearSolve.SimpleNewtonRaphson","page":"SimpleNonlinearSolve.jl","title":"SimpleNonlinearSolve.SimpleNewtonRaphson","text":"SimpleNewtonRaphson(; chunk_size = Val{0}(), autodiff = Val{true}(),\n                                 diff_type = Val{:forward})\n\nA low-overhead implementation of Newton-Raphson. This method is non-allocating on scalar and static array problems.\n\nnote: Note\nAs part of the decreased overhead, this method omits some of the higher level error catching of the other methods. Thus, to see better error messages, use one of the other methods like NewtonRaphson\n\nKeyword Arguments\n\nchunk_size: the chunk size used by the internal ForwardDiff.jl automatic differentiation system. This allows for multiple derivative columns to be computed simultaneously, improving performance. Defaults to 0, which is equivalent to using ForwardDiff.jl's default chunk size mechanism. For more details, see the documentation for ForwardDiff.jl.\nautodiff: whether to use forward-mode automatic differentiation for the Jacobian. Note that this argument is ignored if an analytical Jacobian is passed; as that will be used instead. Defaults to Val{true}, which means ForwardDiff.jl is used by default. If Val{false}, then FiniteDiff.jl is used for finite differencing.\ndiff_type: the type of finite differencing used if autodiff = false. Defaults to Val{:forward} for forward finite differences. For more details on the choices, see the FiniteDiff.jl documentation.\n\n\n\n\n\n","category":"type"},{"location":"api/simplenonlinearsolve/#SimpleNonlinearSolve.Broyden","page":"SimpleNonlinearSolve.jl","title":"SimpleNonlinearSolve.Broyden","text":"Broyden()\n\nA low-overhead implementation of Broyden. This method is non-allocating on scalar and static array problems.\n\n\n\n\n\n","category":"type"},{"location":"api/simplenonlinearsolve/#SimpleNonlinearSolve.Klement","page":"SimpleNonlinearSolve.jl","title":"SimpleNonlinearSolve.Klement","text":"Klement()\n\nA low-overhead implementation of Klement. This method is non-allocating on scalar problems.\n\n\n\n\n\n","category":"type"},{"location":"api/simplenonlinearsolve/#SimpleNonlinearSolve.SimpleTrustRegion","page":"SimpleNonlinearSolve.jl","title":"SimpleNonlinearSolve.SimpleTrustRegion","text":"SimpleTrustRegion(; chunk_size = Val{0}(),\n                    autodiff = Val{true}(),\n                    diff_type = Val{:forward},\n                    max_trust_radius::Real = 0.0,\n                    initial_trust_radius::Real = 0.0,\n                    step_threshold::Real = 0.1,\n                    shrink_threshold::Real = 0.25,\n                    expand_threshold::Real = 0.75,\n                    shrink_factor::Real = 0.25,\n                    expand_factor::Real = 2.0,\n                    max_shrink_times::Int = 32\n\nA low-overhead implementation of a trust-region solver\n\nKeyword Arguments\n\nchunk_size: the chunk size used by the internal ForwardDiff.jl automatic differentiation system. This allows for multiple derivative columns to be computed simultaneously, improving performance. Defaults to 0, which is equivalent to using ForwardDiff.jl's default chunk size mechanism. For more details, see the documentation for ForwardDiff.jl.\nautodiff: whether to use forward-mode automatic differentiation for the Jacobian. Note that this argument is ignored if an analytical Jacobian is passed; as that will be used instead. Defaults to Val{true}, which means ForwardDiff.jl is used by default. If Val{false}, then FiniteDiff.jl is used for finite differencing.\ndiff_type: the type of finite differencing used if autodiff = false. Defaults to Val{:forward} for forward finite differences. For more details on the choices, see the FiniteDiff.jl documentation.\nmax_trust_radius: the maximum radius of the trust region. Defaults to max(norm(f(u0)), maximum(u0) - minimum(u0)).\ninitial_trust_radius: the initial trust region radius. Defaults to max_trust_radius / 11.\nstep_threshold: the threshold for taking a step. In every iteration, the threshold is compared with a value r, which is the actual reduction in the objective function divided by the predicted reduction. If step_threshold > r the model is not a good approximation, and the step is rejected. Defaults to 0.1. For more details, see Trust-region methods\nshrink_threshold: the threshold for shrinking the trust region radius. In every iteration, the threshold is compared with a value r which is the actual reduction in the objective function divided by the predicted reduction. If shrink_threshold > r the trust region radius is shrunk by shrink_factor. Defaults to 0.25. For more details, see Trust-region methods\nexpand_threshold: the threshold for expanding the trust region radius. If a step is taken, i.e step_threshold < r (with r defined in shrink_threshold), a check is also made to see if expand_threshold < r. If that is true, the trust region radius is expanded by expand_factor. Defaults to 0.75.\nshrink_factor: the factor to shrink the trust region radius with if shrink_threshold > r (with r defined in shrink_threshold). Defaults to 0.25.\nexpand_factor: the factor to expand the trust region radius with if expand_threshold < r (with r defined in shrink_threshold). Defaults to 2.0.\nmax_shrink_times: the maximum number of times to shrink the trust region radius in a row, max_shrink_times is exceeded, the algorithm returns. Defaults to 32.\n\n\n\n\n\n","category":"type"},{"location":"api/simplenonlinearsolve/#SimpleNonlinearSolve.Ridder","page":"SimpleNonlinearSolve.jl","title":"SimpleNonlinearSolve.Ridder","text":"Ridder()\n\nA non-allocating ridder method\n\n\n\n\n\n","category":"type"},{"location":"api/simplenonlinearsolve/#SimpleNonlinearSolve.Brent","page":"SimpleNonlinearSolve.jl","title":"SimpleNonlinearSolve.Brent","text":"Brent()\n\nA non-allocating Brent method\n\n\n\n\n\n","category":"type"},{"location":"api/simplenonlinearsolve/#SimpleNonlinearSolve.SimpleDFSane","page":"SimpleNonlinearSolve.jl","title":"SimpleNonlinearSolve.SimpleDFSane","text":"SimpleDFSane(; σ_min::Real = 1e-10, σ_max::Real = 1e10, σ_1::Real = 1.0,\n             M::Int = 10, γ::Real = 1e-4, τ_min::Real = 0.1, τ_max::Real = 0.5,\n             nexp::Int = 2, η_strategy::Function = (f_1, k, x, F) -> f_1 / k^2)\n\nA low-overhead implementation of the df-sane method for solving large-scale nonlinear systems of equations. For in depth information about all the parameters and the algorithm, see the paper: W LaCruz, JM Martinez, and M Raydan (2006), Spectral residual mathod without gradient information for solving large-scale nonlinear systems of equations, Mathematics of Computation, 75, 1429-1448.\n\nKeyword Arguments\n\nσ_min: the minimum value of the spectral coefficient σ_k which is related to the step size in the algorithm. Defaults to 1e-10.\nσ_max: the maximum value of the spectral coefficient σ_k which is related to the step size in the algorithm. Defaults to 1e10.\nσ_1: the initial value of the spectral coefficient σ_k which is related to the step size in the algorithm.. Defaults to 1.0.\nM: The monotonicity of the algorithm is determined by a this positive integer. A value of 1 for M would result in strict monotonicity in the decrease of the L2-norm of the function f. However, higher values allow for more flexibility in this reduction. Despite this, the algorithm still ensures global convergence through the use of a non-monotone line-search algorithm that adheres to the Grippo-Lampariello-Lucidi condition. Values in the range of 5 to 20 are usually sufficient, but some cases may call for a higher value of M. The default setting is 10.\nγ: a parameter that influences if a proposed step will be accepted. Higher value of γ will make the algorithm more restrictive in accepting steps. Defaults to 1e-4.\nτ_min: if a step is rejected the new step size will get multiplied by factor, and this parameter is the minimum value of that factor. Defaults to 0.1.\nτ_max: if a step is rejected the new step size will get multiplied by factor, and this parameter is the maximum value of that factor. Defaults to 0.5.\nnexp: the exponent of the loss, i.e. f_k=F(x_k)^nexp. The paper uses nexp ∈ {1,2}. Defaults to 2.\nη_strategy:  function to determine the parameter η_k, which enables growth of F^2. Called as η_k = η_strategy(f_1 k x F) with f_1 initialized as f_1=F(x_1)^nexp, k is the iteration number, x is the current x-value and F the current residual. Should satisfy η_k  0 and ₖ ηₖ  . Defaults to F^2  k^2.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/iterator_interface/#Nonlinear-Solver-Iterator-Interface","page":"Nonlinear Solver Iterator Interface","title":"Nonlinear Solver Iterator Interface","text":"","category":"section"},{"location":"tutorials/iterator_interface/","page":"Nonlinear Solver Iterator Interface","title":"Nonlinear Solver Iterator Interface","text":"There is an iterator form of the nonlinear solver which mirrors the DiffEq integrator interface:","category":"page"},{"location":"tutorials/iterator_interface/","page":"Nonlinear Solver Iterator Interface","title":"Nonlinear Solver Iterator Interface","text":"using NonlinearSolve\nf(u, p) = u .* u .- 2.0\nu0 = 1.5\nprobB = NonlinearProblem(f, u0)\ncache = init(probB, NewtonRaphson()) # Can iterate the solver object\nsolver = solve!(cache)","category":"page"},{"location":"api/nlsolve/#NLsolve.jl","page":"NLsolve.jl","title":"NLsolve.jl","text":"","category":"section"},{"location":"api/nlsolve/","page":"NLsolve.jl","title":"NLsolve.jl","text":"This is a wrapper package for importing solvers from NLsolve.jl into the SciML interface. Note that these solvers do not come by default, and thus one needs to install the package before using these solvers:","category":"page"},{"location":"api/nlsolve/","page":"NLsolve.jl","title":"NLsolve.jl","text":"using Pkg\nPkg.add(\"SciMLNLSolve\")\nusing SciMLNLSolve","category":"page"},{"location":"api/nlsolve/#Solver-API","page":"NLsolve.jl","title":"Solver API","text":"","category":"section"},{"location":"api/nlsolve/","page":"NLsolve.jl","title":"NLsolve.jl","text":"NLSolveJL","category":"page"},{"location":"api/nlsolve/#SciMLNLSolve.NLSolveJL","page":"NLsolve.jl","title":"SciMLNLSolve.NLSolveJL","text":"NLSolveJL(;\n          method=:trust_region,\n          autodiff=:central,\n          store_trace=false,\n          extended_trace=false,\n          linesearch=LineSearches.Static(),\n          linsolve=(x, A, b) -> copyto!(x, A\\b),\n          factor = one(Float64),\n          autoscale=true,\n          m=10,\n          beta=one(Float64),\n          show_trace=false,\n       )\n\nKeyword Arguments\n\nmethod: the choice of method for solving the nonlinear system.\nautodiff: the choice of method for generating the Jacobian. Defaults to :central or central differencing via FiniteDiff.jl. The other choices are :forward\nshow_trace: should a trace of the optimization algorithm's state be shown on STDOUT? Default: false.\nextended_trace: should additional algorithm internals be added to the state trace? Default: false.\nlinesearch: the line search method to be used within the solver method. The choices are line search types from LineSearches.jl. Defaults to LineSearches.Static().\nlinsolve: a function linsolve(x, A, b) that solves Ax = b. Defaults to using Julia's \\.\nfactor: determines the size of the initial trust region. This size is set to the product of factor and the euclidean norm ofu0` if nonzero, or else to factor itself. Default: 1.0.\nautoscale: if true, then the variables will be automatically rescaled. The scaling factors are the norms of the Jacobian columns. Default: true.\nm: the amount of history in the Anderson method. Naive \"Picard\"-style iteration can be achieved by setting m=0, but that isn't advisable for contractions whose Lipschitz constants are close to 1. If convergence fails, though, you may consider lowering it.\nbeta: It is also known as DIIS or Pulay mixing, this method is based on the acceleration of the fixed-point iteration xₙ₊₁ = xₙ + beta*f(xₙ), where by default beta=1.\nstore_trace`: should a trace of the optimization algorithm's state be stored? Default: false.\n\nSubmethod Choice\n\nChoices for methods in NLSolveJL:\n\n:fixedpoint: Fixed-point iteration\n:anderson: Anderson-accelerated fixed-point iteration\n:newton: Classical Newton method with an optional line search\n:trust_region: Trust region Newton method (the default choice)\n\nFor more information on these arguments, consult the NLsolve.jl documentation.\n\n\n\n\n\n","category":"type"},{"location":"api/sundials/#Sundials.jl","page":"Sundials.jl","title":"Sundials.jl","text":"","category":"section"},{"location":"api/sundials/","page":"Sundials.jl","title":"Sundials.jl","text":"This is a wrapper package for importing solvers from Sundials into the SciML interface. Note that these solvers do not come by default, and thus one needs to install the package before using these solvers:","category":"page"},{"location":"api/sundials/","page":"Sundials.jl","title":"Sundials.jl","text":"using Pkg\nPkg.add(\"Sundials\")\nusing Sundials","category":"page"},{"location":"api/sundials/","page":"Sundials.jl","title":"Sundials.jl","text":"These methods can be used independently of the rest of NonlinearSolve.jl.","category":"page"},{"location":"api/sundials/#Solver-API","page":"Sundials.jl","title":"Solver API","text":"","category":"section"},{"location":"api/sundials/","page":"Sundials.jl","title":"Sundials.jl","text":"KINSOL","category":"page"},{"location":"api/sundials/#Sundials.KINSOL","page":"Sundials.jl","title":"Sundials.KINSOL","text":"KINSOL: Newton-Krylov technique solver\n\nKINSOL(;\n    linear_solver = :Dense,\n    jac_upper = 0,\n    jac_lower = 0,\n    userdata = nothing,\n)\n\nThe choices for the linear solver are:\n\n:Dense: A dense linear solver\n:Band: A solver specialized for banded Jacobians. If used, you must set the position of the upper and lower non-zero diagonals via jac_upper and jac_lower.\n:LapackDense: A version of the dense linear solver that uses the Julia-provided OpenBLAS-linked LAPACK for multithreaded operations. This will be faster than :Dense on larger systems but has noticeable overhead on smaller (<100 ODE) systems.\n:LapackBand: A version of the banded linear solver that uses the Julia-provided OpenBLAS-linked LAPACK for multithreaded operations. This will be faster than :Band on larger systems but has noticeable overhead on smaller (<100 ODE) systems.\n:Diagonal: This method is specialized for diagonal Jacobians.\n:GMRES: A GMRES method. Recommended first choice Krylov method.\n:BCG: A biconjugate gradient method\n:PCG: A preconditioned conjugate gradient method. Only for symmetric linear systems.\n:TFQMR: A TFQMR method.\n:KLU: A sparse factorization method. Requires that the user specify a Jacobian. The Jacobian must be set as a sparse matrix in the ODEProblem type.\n\n\n\n\n\n","category":"type"},{"location":"api/minpack/#MINPACK.jl","page":"MINPACK.jl","title":"MINPACK.jl","text":"","category":"section"},{"location":"api/minpack/","page":"MINPACK.jl","title":"MINPACK.jl","text":"This is a wrapper package for importing solvers from Sundials into the SciML interface. Note that these solvers do not come by default, and thus one needs to install the package before using these solvers:","category":"page"},{"location":"api/minpack/","page":"MINPACK.jl","title":"MINPACK.jl","text":"using Pkg\nPkg.add(\"NonlinearSolveMINPACK\")\nusing NonlinearSolveMINPACK","category":"page"},{"location":"api/minpack/","page":"MINPACK.jl","title":"MINPACK.jl","text":"These methods can be used independently of the rest of NonlinearSolve.jl","category":"page"},{"location":"api/minpack/#Solver-API","page":"MINPACK.jl","title":"Solver API","text":"","category":"section"},{"location":"api/minpack/","page":"MINPACK.jl","title":"MINPACK.jl","text":"CMINPACK","category":"page"},{"location":"api/minpack/#NonlinearSolveMINPACK.CMINPACK","page":"MINPACK.jl","title":"NonlinearSolveMINPACK.CMINPACK","text":"CMINPACK(;show_trace::Bool=false, tracing::Bool=false, method::Symbol=:hybr,\n          io::IO=stdout)\n\nKeyword Arguments\n\nshow_trace: whether to show the trace.\ntracing: who the hell knows what this does. If you find out, please open an issue/PR.\nmethod: the choice of method for the solver.\nio: the IO to print any tracing output to.\n\nMethod Choices\n\nThe keyword argument method can take on different value depending on which method of fsolve you are calling. The standard choices of method are:\n\n:hybr: Modified version of Powell's algorithm. Uses MINPACK routine hybrd1\n:lm: Levenberg-Marquardt. Uses MINPACK routine lmdif1\n:lmdif: Advanced Levenberg-Marquardt (more options available with ;kwargs...). See MINPACK routine lmdif for more information\n:hybrd: Advacned modified version of Powell's algorithm (more options available with ;kwargs...). See MINPACK routine hybrd for more information\n\nIf a Jacobian is supplied as part of the NonlinearFunction, then the following methods are allowed:\n\n:hybr: Advacned modified version of Powell's algorithm with user supplied Jacobian. Additional arguments are available via ;kwargs.... See MINPACK routine hybrj for more information\n:lm: Advanced Levenberg-Marquardt with user supplied Jacobian. Additional arguments are available via ;kwargs.... See MINPACK routine lmder for more information\n\n\n\n\n\n","category":"type"},{"location":"basics/solve/#solver_options","page":"Common Solver Options (Solve Keyword Arguments)","title":"Common Solver Options (Solve Keyword Arguments)","text":"","category":"section"},{"location":"basics/solve/","page":"Common Solver Options (Solve Keyword Arguments)","title":"Common Solver Options (Solve Keyword Arguments)","text":"solve(prob::SciMLBase.NonlinearProblem,args...;kwargs...)","category":"page"},{"location":"solvers/BracketingSolvers/#Interval-Rootfinding-Methods-(Bracketing-Solvers)","page":"Interval Rootfinding Methods (Bracketing Solvers)","title":"Interval Rootfinding Methods (Bracketing Solvers)","text":"","category":"section"},{"location":"solvers/BracketingSolvers/","page":"Interval Rootfinding Methods (Bracketing Solvers)","title":"Interval Rootfinding Methods (Bracketing Solvers)","text":"solve(prob::IntervalNonlinearProblem,alg;kwargs)","category":"page"},{"location":"solvers/BracketingSolvers/","page":"Interval Rootfinding Methods (Bracketing Solvers)","title":"Interval Rootfinding Methods (Bracketing Solvers)","text":"Solves for f(t)=0 in the problem defined by prob using the algorithm alg. If no algorithm is given, a default algorithm will be chosen.","category":"page"},{"location":"solvers/BracketingSolvers/#Recommended-Methods","page":"Interval Rootfinding Methods (Bracketing Solvers)","title":"Recommended Methods","text":"","category":"section"},{"location":"solvers/BracketingSolvers/","page":"Interval Rootfinding Methods (Bracketing Solvers)","title":"Interval Rootfinding Methods (Bracketing Solvers)","text":"Falsi() can have a faster convergence and is discretely differentiable, but is less stable than Bisection. Ridder is a hybrid method that uses the value of function at the midpoint of the interval to perform an exponential interpolation to the root. This gives a fast convergence with a guaranteed convergence of at most twice the number of iterations as the bisection method. Brent is a combination of the bisection method, the secant method and inverse quadratic interpolation. At every iteration, Brent's method decides which method out of these three is likely to do best, and proceeds by doing a step according to that method. This gives a robust and fast method, which therefore enjoys considerable popularity.","category":"page"},{"location":"solvers/BracketingSolvers/#Full-List-of-Methods","page":"Interval Rootfinding Methods (Bracketing Solvers)","title":"Full List of Methods","text":"","category":"section"},{"location":"solvers/BracketingSolvers/#SimpleNonlinearSolve.jl","page":"Interval Rootfinding Methods (Bracketing Solvers)","title":"SimpleNonlinearSolve.jl","text":"","category":"section"},{"location":"solvers/BracketingSolvers/","page":"Interval Rootfinding Methods (Bracketing Solvers)","title":"Interval Rootfinding Methods (Bracketing Solvers)","text":"These methods are automatically included as part of NonlinearSolve.jl. Though, one can use SimpleNonlinearSolve.jl directly to decrease the dependencies and improve load time.","category":"page"},{"location":"solvers/BracketingSolvers/","page":"Interval Rootfinding Methods (Bracketing Solvers)","title":"Interval Rootfinding Methods (Bracketing Solvers)","text":"Falsi: A non-allocating regula falsi method\nBisection: A common bisection method\nRidder: A non-allocating Ridder method\nBrent: A non-allocating Brent method","category":"page"},{"location":"basics/NonlinearProblem/#Nonlinear-Problems","page":"Nonlinear Problems","title":"Nonlinear Problems","text":"","category":"section"},{"location":"basics/NonlinearProblem/#The-Three-Types-of-Nonlinear-Problems","page":"Nonlinear Problems","title":"The Three Types of Nonlinear Problems","text":"","category":"section"},{"location":"basics/NonlinearProblem/","page":"Nonlinear Problems","title":"Nonlinear Problems","text":"NonlinearSolve.jl tackles three related types of nonlinear systems:","category":"page"},{"location":"basics/NonlinearProblem/","page":"Nonlinear Problems","title":"Nonlinear Problems","text":"Interval rootfinding problems. I.e., find the t in t_0 t_f such that f(t) = 0.\nSystems of nonlinear equations, i.e., find the u such that f(u) = 0.\nSteady state problems, i.e., find the u such that u = f(ut) has reached steady state, i.e., 0 = f(u ).","category":"page"},{"location":"basics/NonlinearProblem/","page":"Nonlinear Problems","title":"Nonlinear Problems","text":"The first is for solving scalar rootfinding problems, i.e., finding a single number, and requires that a bracketing interval is known. For a bracketing interval, one must have that the sign of f(t_0) is opposite the sign of f(t_f), thus guaranteeing a root in the interval.","category":"page"},{"location":"basics/NonlinearProblem/","page":"Nonlinear Problems","title":"Nonlinear Problems","text":"note: Note\nInterval rootfinding problems allow for f to return an array, in which case the interval rootfinding problem is interpreted as finding the first t such that any of the components of the array hit zero.","category":"page"},{"location":"basics/NonlinearProblem/","page":"Nonlinear Problems","title":"Nonlinear Problems","text":"The second type of nonlinear system can be multidimensional, and thus no ordering nor boundaries are assumed to be known. For a system of nonlinear equations, f can return an array, and the solver seeks the value of u for which all outputs of f are simultaneously zero.","category":"page"},{"location":"basics/NonlinearProblem/","page":"Nonlinear Problems","title":"Nonlinear Problems","text":"The last type if equivalent to a nonlinear system, but with the extra interpretation of having a potentially preferred unique root. That is, when there are multiple u such that f(u) = 0, the NonlinearProblem does not have a preferred solution, while for the SteadyStateProblem the preferred solution is the u(∞) that would arise from solving the ODE u' = f(u,t).","category":"page"},{"location":"basics/NonlinearProblem/","page":"Nonlinear Problems","title":"Nonlinear Problems","text":"warn: Warn\nMost solvers for SteadyStateProblem do not guarantee the preferred solution and instead will solve for some u in the set of solutions. The documentation of the nonlinear solvers will note if they return the preferred solution.","category":"page"},{"location":"basics/NonlinearProblem/#Problem-Construction-Details","page":"Nonlinear Problems","title":"Problem Construction Details","text":"","category":"section"},{"location":"basics/NonlinearProblem/","page":"Nonlinear Problems","title":"Nonlinear Problems","text":"SciMLBase.IntervalNonlinearProblem\nSciMLBase.NonlinearProblem\nSciMLBase.SteadyStateProblem","category":"page"},{"location":"basics/NonlinearProblem/#SciMLBase.IntervalNonlinearProblem","page":"Nonlinear Problems","title":"SciMLBase.IntervalNonlinearProblem","text":"Defines an interval nonlinear system problem. Documentation Page: https://docs.sciml.ai/NonlinearSolve/stable/basics/NonlinearProblem/\n\nMathematical Specification of an Interval Nonlinear Problem\n\nTo define a Nonlinear Problem, you simply need to give the function f which defines the nonlinear system:\n\nf(tp) = u = 0\n\nalong with an interval tspan, t in t_0t_f, within which the root should be found. f should be specified as f(t,p) (or in-place as f(u,t,p)), and tspan should be a Tuple{T,T} where T <: Number.\n\nnote: Note\nThe output value u is not required to be a scalar. When u is an AbstractArray, the problem is a simultaneous interval nonlinear problem where the solvers are made to give the first t for which any of the u hit zero. Currently, none of the solvers support this mode.\n\nProblem Type\n\nConstructors\n\nIntervalNonlinearProblem(f::NonlinearFunction,tspan,p=NullParameters();kwargs...)\nIntervalNonlinearProblem{isinplace}(f,tspan,p=NullParameters();kwargs...)\n\nisinplace optionally sets whether the function is in-place or not. This is determined automatically, but not inferred.\n\nParameters are optional, and if not given, then a NullParameters() singleton will be used, which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a callback in the problem, then that callback will be added in every solve call.\n\nFields\n\nf: The function in the problem.\ntspan: The interval in which the root is to be found.\np: The parameters for the problem. Defaults to NullParameters.\nkwargs: The keyword arguments passed on to the solvers.\n\n\n\n","category":"type"},{"location":"basics/NonlinearProblem/#SciMLBase.NonlinearProblem","page":"Nonlinear Problems","title":"SciMLBase.NonlinearProblem","text":"Defines a nonlinear system problem. Documentation Page: https://docs.sciml.ai/NonlinearSolve/stable/basics/NonlinearProblem/\n\nMathematical Specification of a Nonlinear Problem\n\nTo define a Nonlinear Problem, you simply need to give the function f which defines the nonlinear system:\n\nf(up) = 0\n\nand an initial guess u₀ of where f(u,p)=0. f should be specified as f(u,p) (or in-place as f(du,u,p)), and u₀ should be an AbstractArray (or number) whose geometry matches the desired geometry of u. Note that we are not limited to numbers or vectors for u₀; one is allowed to provide u₀ as arbitrary matrices / higher-dimension tensors as well.\n\nProblem Type\n\nConstructors\n\nNonlinearProblem(f::NonlinearFunction,u0,p=NullParameters();kwargs...)\nNonlinearProblem{isinplace}(f,u0,p=NullParameters();kwargs...)\n\nisinplace optionally sets whether the function is in-place or not. This is determined automatically, but not inferred.\n\nParameters are optional, and if not given, then a NullParameters() singleton will be used, which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a callback in the problem, then that callback will be added in every solve call.\n\nFor specifying Jacobians and mass matrices, see the NonlinearFunctions page.\n\nFields\n\nf: The function in the problem.\nu0: The initial guess for the root.\np: The parameters for the problem. Defaults to NullParameters.\nkwargs: The keyword arguments passed on to the solvers.\n\n\n\n","category":"type"},{"location":"basics/NonlinearProblem/#SciMLBase.SteadyStateProblem","page":"Nonlinear Problems","title":"SciMLBase.SteadyStateProblem","text":"Defines a steady state ODE problem. Documentation Page: https://docs.sciml.ai/DiffEqDocs/stable/types/steadystatetypes/\n\nMathematical Specification of a Steady State Problem\n\nTo define a Steady State Problem, you simply need to give the function f which defines the ODE:\n\nfracdudt = f(upt)\n\nand an initial guess u_0 of where f(u,p,t)=0. f should be specified as f(u,p,t) (or in-place as f(du,u,p,t)), and u₀ should be an AbstractArray (or number) whose geometry matches the desired geometry of u. Note that we are not limited to numbers or vectors for u₀; one is allowed to provide u₀ as arbitrary matrices / higher dimension tensors as well.\n\nNote that for the steady-state to be defined, we must have that f is autonomous, that is f is independent of t. But the form which matches the standard ODE solver should still be used. The steady state solvers interpret the f by fixing t=infty.\n\nProblem Type\n\nConstructors\n\nSteadyStateProblem(f::ODEFunction,u0,p=NullParameters();kwargs...)\nSteadyStateProblem{isinplace,specialize}(f,u0,p=NullParameters();kwargs...)\n\nisinplace optionally sets whether the function is inplace or not. This is determined automatically, but not inferred. specialize optionally controls the specialization level. See the specialization levels section of the SciMLBase documentation for more details. The default is AutoSpecialize.\n\nParameters are optional, and if not given, a NullParameters() singleton will be used, which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a callback in the problem, then that callback will be added in every solve call.\n\nAdditionally, the constructor from ODEProblems is provided:\n\nSteadyStateProblem(prob::ODEProblem)\n\nParameters are optional, and if not given, a NullParameters() singleton will be used, which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a callback in the problem, then that callback will be added in every solve call.\n\nFor specifying Jacobians and mass matrices, see the DiffEqFunctions page.\n\nFields\n\nf: The function in the ODE.\nu0: The initial guess for the steady state.\np: The parameters for the problem. Defaults to NullParameters\nkwargs: The keyword arguments passed onto the solves.\n\nSpecial Solution Fields\n\nThe SteadyStateSolution type is different from the other DiffEq solutions because it does not have temporal information.\n\n\n\n","category":"type"},{"location":"api/nonlinearsolve/#NonlinearSolve.jl-Native-Solvers","page":"NonlinearSolve.jl Native Solvers","title":"NonlinearSolve.jl Native Solvers","text":"","category":"section"},{"location":"api/nonlinearsolve/","page":"NonlinearSolve.jl Native Solvers","title":"NonlinearSolve.jl Native Solvers","text":"These are the native solvers of NonlinearSolve.jl.","category":"page"},{"location":"api/nonlinearsolve/#Solver-API","page":"NonlinearSolve.jl Native Solvers","title":"Solver API","text":"","category":"section"},{"location":"api/nonlinearsolve/","page":"NonlinearSolve.jl Native Solvers","title":"NonlinearSolve.jl Native Solvers","text":"NewtonRaphson\nTrustRegion","category":"page"},{"location":"api/nonlinearsolve/#NonlinearSolve.NewtonRaphson","page":"NonlinearSolve.jl Native Solvers","title":"NonlinearSolve.NewtonRaphson","text":"NewtonRaphson(; chunk_size = Val{0}(), autodiff = Val{true}(),\n              standardtag = Val{true}(), concrete_jac = nothing,\n              diff_type = Val{:forward}, linsolve = nothing, precs = DEFAULT_PRECS)\n\nAn advanced NewtonRaphson implementation with support for efficient handling of sparse matrices via colored automatic differentiation and preconditioned linear solvers. Designed for large-scale and numerically-difficult nonlinear systems.\n\nKeyword Arguments\n\nchunk_size: the chunk size used by the internal ForwardDiff.jl automatic differentiation system. This allows for multiple derivative columns to be computed simultaneously, improving performance. Defaults to 0, which is equivalent to using ForwardDiff.jl's default chunk size mechanism. For more details, see the documentation for ForwardDiff.jl.\nautodiff: whether to use forward-mode automatic differentiation for the Jacobian. Note that this argument is ignored if an analytical Jacobian is passed, as that will be used instead. Defaults to Val{true}, which means ForwardDiff.jl via SparseDiffTools.jl is used by default. If Val{false}, then FiniteDiff.jl is used for finite differencing.\nstandardtag: whether to use a standardized tag definition for the purposes of automatic differentiation. Defaults to true, which thus uses the NonlinearSolveTag. If Val{false}, then ForwardDiff's default function naming tag is used, which results in larger stack traces.\nconcrete_jac: whether to build a concrete Jacobian. If a Krylov-subspace method is used, then the Jacobian will not be constructed and instead direct Jacobian-vector products J*v are computed using forward-mode automatic differentiation or finite differencing tricks (without ever constructing the Jacobian). However, if the Jacobian is still needed, for example for a preconditioner, concrete_jac = true can be passed in order to force the construction of the Jacobian.\ndiff_type: the type of finite differencing used if autodiff = false. Defaults to Val{:forward} for forward finite differences. For more details on the choices, see the FiniteDiff.jl documentation.\nlinsolve: the LinearSolve.jl used for the linear solves within the Newton method. Defaults to nothing, which means it uses the LinearSolve.jl default algorithm choice. For more information on available algorithm choices, see the LinearSolve.jl documentation.\nprecs: the choice of preconditioners for the linear solver. Defaults to using no preconditioners. For more information on specifying preconditioners for LinearSolve algorithms, consult the LinearSolve.jl documentation.\n\nnote: Note\nCurrently, the linear solver and chunk size choice only applies to in-place defined NonlinearProblems. That is expected to change in the future.\n\n\n\n\n\n","category":"type"},{"location":"api/nonlinearsolve/#NonlinearSolve.TrustRegion","page":"NonlinearSolve.jl Native Solvers","title":"NonlinearSolve.TrustRegion","text":"TrustRegion(; chunk_size = Val{0}(), autodiff = Val{true}(),\n            standardtag = Val{true}(), concrete_jac = nothing,\n            diff_type = Val{:forward}, linsolve = nothing, precs = DEFAULT_PRECS,\n            max_trust_radius::Real = 0 // 1,\n            initial_trust_radius::Real = 0 // 1,\n            step_threshold::Real = 1 // 10,\n            shrink_threshold::Real = 1 // 4,\n            expand_threshold::Real = 3 // 4,\n            shrink_factor::Real = 1 // 4,\n            expand_factor::Real = 2 // 1,\n            max_shrink_times::Int = 32)\n\nAn advanced TrustRegion implementation with support for efficient handling of sparse matrices via colored automatic differentiation and preconditioned linear solvers. Designed for large-scale and numerically-difficult nonlinear systems.\n\nKeyword Arguments\n\nchunk_size: the chunk size used by the internal ForwardDiff.jl automatic differentiation system. This allows for multiple derivative columns to be computed simultaneously, improving performance. Defaults to 0, which is equivalent to using ForwardDiff.jl's default chunk size mechanism. For more details, see the documentation for ForwardDiff.jl.\nautodiff: whether to use forward-mode automatic differentiation for the Jacobian. Note that this argument is ignored if an analytical Jacobian is passed, as that will be used instead. Defaults to Val{true}, which means ForwardDiff.jl via SparseDiffTools.jl is used by default. If Val{false}, then FiniteDiff.jl is used for finite differencing.\nstandardtag: whether to use a standardized tag definition for the purposes of automatic differentiation. Defaults to true, which thus uses the NonlinearSolveTag. If Val{false}, then ForwardDiff's default function naming tag is used, which results in larger stack traces.\nconcrete_jac: whether to build a concrete Jacobian. If a Krylov-subspace method is used, then the Jacobian will not be constructed and instead direct Jacobian-vector products J*v are computed using forward-mode automatic differentiation or finite differencing tricks (without ever constructing the Jacobian). However, if the Jacobian is still needed, for example for a preconditioner, concrete_jac = true can be passed in order to force the construction of the Jacobian.\ndiff_type: the type of finite differencing used if autodiff = false. Defaults to Val{:forward} for forward finite differences. For more details on the choices, see the FiniteDiff.jl documentation.\nlinsolve: the LinearSolve.jl used for the linear solves within the Newton method. Defaults to nothing, which means it uses the LinearSolve.jl default algorithm choice. For more information on available algorithm choices, see the LinearSolve.jl documentation.\nprecs: the choice of preconditioners for the linear solver. Defaults to using no preconditioners. For more information on specifying preconditioners for LinearSolve algorithms, consult the LinearSolve.jl documentation.\nmax_trust_radius: the maximal trust region radius. Defaults to max(norm(fu), maximum(u) - minimum(u)).\ninitial_trust_radius: the initial trust region radius. Defaults to max_trust_radius / 11.\nstep_threshold: the threshold for taking a step. In every iteration, the threshold is compared with a value r, which is the actual reduction in the objective function divided by the predicted reduction. If step_threshold > r the model is not a good approximation, and the step is rejected. Defaults to 0.1. For more details, see Trust-region methods\nshrink_threshold: the threshold for shrinking the trust region radius. In every iteration, the threshold is compared with a value r which is the actual reduction in the objective function divided by the predicted reduction. If shrink_threshold > r the trust region radius is shrunk by shrink_factor. Defaults to 0.25. For more details, see Trust-region methods\nexpand_threshold: the threshold for expanding the trust region radius. If a step is taken, i.e step_threshold < r (with r defined in shrink_threshold), a check is also made to see if expand_threshold < r. If that is true, the trust region radius is expanded by expand_factor. Defaults to 0.75.\nshrink_factor: the factor to shrink the trust region radius with if shrink_threshold > r (with r defined in shrink_threshold). Defaults to 0.25.\nexpand_factor: the factor to expand the trust region radius with if expand_threshold < r (with r defined in shrink_threshold). Defaults to 2.0.\nmax_shrink_times: the maximum number of times to shrink the trust region radius in a row, max_shrink_times is exceeded, the algorithm returns. Defaults to 32.\n\nnote: Note\nCurrently, the linear solver and chunk size choice only applies to in-place defined NonlinearProblems. That is expected to change in the future.\n\n\n\n\n\n","category":"type"},{"location":"solvers/NonlinearSystemSolvers/#nonlinearsystemsolvers","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"","category":"section"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"solve(prob::NonlinearProblem,alg;kwargs)","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"Solves for f(u)=0 in the problem defined by prob using the algorithm alg. If no algorithm is given, a default algorithm will be chosen.","category":"page"},{"location":"solvers/NonlinearSystemSolvers/#Recommended-Methods","page":"Nonlinear System Solvers","title":"Recommended Methods","text":"","category":"section"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"TrustRegion is a good choice for most problems. For large systems, it can make use of sparsity patterns for sparse automatic differentiation and sparse linear solving of very large systems. That said, as a classic Newton method, its stability region can be smaller than other methods. Meanwhile, SimpleNewtonRaphson and SimpleTrustRegion are implementations which are specialized for small equations. They are non-allocating on static arrays and thus really well-optimized for small systems, thus usually outperforming the other methods when such types are used for u0. DynamicSS can be a good choice for high stability.","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"For a system which is very non-stiff (i.e., the condition number of the Jacobian is small, or the eigenvalues of the Jacobian are within a few orders of magnitude), then NLSolveJL's :anderson can be a good choice.","category":"page"},{"location":"solvers/NonlinearSystemSolvers/#Full-List-of-Methods","page":"Nonlinear System Solvers","title":"Full List of Methods","text":"","category":"section"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"note: Note\nFor the full details on the capabilities and constructors of the different solvers, see the Detailed Solver APIs section!","category":"page"},{"location":"solvers/NonlinearSystemSolvers/#NonlinearSolve.jl","page":"Nonlinear System Solvers","title":"NonlinearSolve.jl","text":"","category":"section"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"These are the core solvers, which excel at large-scale problems that need advanced linear solver, automatic differentiation, abstract array types, GPU, sparse/structured matrix support, etc. These methods support the largest set of types and features, but have a bit of overhead on very small problems.","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"NewtonRaphson():A Newton-Raphson method with swappable nonlinear solvers and autodiff methods for high performance on large and sparse systems.\nTrustRegion(): A Newton Trust Region dogleg method with swappable nonlinear solvers and autodiff methods for high performance on large and sparse systems.","category":"page"},{"location":"solvers/NonlinearSystemSolvers/#SimpleNonlinearSolve.jl","page":"Nonlinear System Solvers","title":"SimpleNonlinearSolve.jl","text":"","category":"section"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"These methods are included with NonlinearSolve.jl by default, though SimpleNonlinearSolve.jl can be used directly to reduce dependencies and improve load times. SimpleNonlinearSolve.jl's methods excel at small problems and problems defined with static arrays.","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"SimpleNewtonRaphson(): A simplified implementation of the Newton-Raphson method.\nBroyden(): The classic Broyden's quasi-Newton method.\nKlement(): A quasi-Newton method due to Klement. It's supposed to be more efficient than Broyden's method, and it seems to be in the cases that have been tried, but more benchmarking is required.\nSimpleTrustRegion(): A dogleg trust-region Newton method. Improved globalizing stability for more robust fitting over basic Newton methods, though potentially with a cost.\nSimpleDFSane(): A low-overhead implementation of the df-sane method for solving large-scale nonlinear systems of equations.","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"note: Note\nWhen used with certain types for the states u such as a Number or StaticArray, these solvers are very efficient and non-allocating. These implementations are thus well-suited for small systems of equations.","category":"page"},{"location":"solvers/NonlinearSystemSolvers/#SteadyStateDiffEq.jl","page":"Nonlinear System Solvers","title":"SteadyStateDiffEq.jl","text":"","category":"section"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"SteadyStateDiffEq.jl uses ODE solvers to iteratively approach the steady state. It is a very stable method for solving nonlinear systems, though often more computationally expensive than direct methods.","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"DynamicSS() : Uses an ODE solver to find the steady state. Automatically terminates when close to the steady state.","category":"page"},{"location":"solvers/NonlinearSystemSolvers/#SciMLNLSolve.jl","page":"Nonlinear System Solvers","title":"SciMLNLSolve.jl","text":"","category":"section"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"This is a wrapper package for importing solvers from NLsolve.jl into the SciML interface.","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"NLSolveJL(): A wrapper for NLsolve.jl","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"Submethod choices for this algorithm include:","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":":fixedpoint: Fixed-point iteration\n:anderson: Anderson-accelerated fixed-point iteration\n:newton: Classical Newton method with an optional line search\n:trust_region: Trust region Newton method (the default choice)","category":"page"},{"location":"solvers/NonlinearSystemSolvers/#MINPACK.jl","page":"Nonlinear System Solvers","title":"MINPACK.jl","text":"","category":"section"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"MINPACK.jl methods are good for medium-sized nonlinear solves. It does not scale due to the lack of sparse Jacobian support, though the methods are very robust and stable.","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"CMINPACK(): A wrapper for using the classic MINPACK method through MINPACK.jl","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"Submethod choices for this algorithm include:","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":":hybr: Modified version of Powell's algorithm.\n:lm: Levenberg-Marquardt.\n:lmdif: Advanced Levenberg-Marquardt\n:hybrd: Advanced modified version of Powell's algorithm","category":"page"},{"location":"solvers/NonlinearSystemSolvers/#Sundials.jl","page":"Nonlinear System Solvers","title":"Sundials.jl","text":"","category":"section"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"Sundials.jl are a classic set of C/Fortran methods which are known for good scaling of the Newton-Krylov form. However, KINSOL is known to be less stable than some other implementations, as it has no line search or globalizer (trust region).","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"KINSOL(): The KINSOL method of the SUNDIALS C library","category":"page"},{"location":"api/steadystatediffeq/#SteadyStateDiffEq.jl","page":"SteadyStateDiffEq.jl","title":"SteadyStateDiffEq.jl","text":"","category":"section"},{"location":"api/steadystatediffeq/","page":"SteadyStateDiffEq.jl","title":"SteadyStateDiffEq.jl","text":"This is a wrapper package for using ODE solvers from DifferentialEquations.jl into the SciML interface. Note that these solvers do not come by default, and thus one needs to install the package before using these solvers:","category":"page"},{"location":"api/steadystatediffeq/","page":"SteadyStateDiffEq.jl","title":"SteadyStateDiffEq.jl","text":"using Pkg\nPkg.add(\"SteadyStateDiffEq\")\nusing SteadyStateDiffEq","category":"page"},{"location":"api/steadystatediffeq/","page":"SteadyStateDiffEq.jl","title":"SteadyStateDiffEq.jl","text":"These methods can be used independently of the rest of NonlinearSolve.jl","category":"page"},{"location":"api/steadystatediffeq/#Solver-API","page":"SteadyStateDiffEq.jl","title":"Solver API","text":"","category":"section"},{"location":"api/steadystatediffeq/","page":"SteadyStateDiffEq.jl","title":"SteadyStateDiffEq.jl","text":"DynamicSS","category":"page"},{"location":"api/steadystatediffeq/#SteadyStateDiffEq.DynamicSS","page":"SteadyStateDiffEq.jl","title":"SteadyStateDiffEq.DynamicSS","text":"DynamicSS(alg;abstol=1e-8,reltol=1e-6,tspan=Inf)\n\nRequires that an ODE algorithm is given as the first argument.  The absolute and relative tolerances specify the termination conditions on the derivative's closeness to zero.  This internally uses the TerminateSteadyState callback from the Callback Library. The simulated time for which given ODE is solved can be limited by tspan.  If tspan is a number, it is equivalent to passing (zero(tspan), tspan).\n\nExample usage:\n\nusing SteadyStateDiffEq, OrdinaryDiffEq\nsol = solve(prob,DynamicSS(Tsit5()))\n\nusing Sundials\nsol = solve(prob,DynamicSS(CVODE_BDF()),dt=1.0)\n\nnote: Note\nIf you use CVODE_BDF you may need to give a starting dt via dt=.....*\n\n\n\n\n\n","category":"type"},{"location":"tutorials/nonlinear/#Solving-Nonlinear-Systems","page":"Solving Nonlinear Systems","title":"Solving Nonlinear Systems","text":"","category":"section"},{"location":"tutorials/nonlinear/","page":"Solving Nonlinear Systems","title":"Solving Nonlinear Systems","text":"A nonlinear system f(u) = 0 is specified by defining a function f(u,p), where p are the parameters of the system. For example, the following solves the vector equation f(u) = u^2 - p for a vector of equations:","category":"page"},{"location":"tutorials/nonlinear/","page":"Solving Nonlinear Systems","title":"Solving Nonlinear Systems","text":"using NonlinearSolve, StaticArrays\n\nf(u, p) = u .* u .- p\nu0 = @SVector[1.0, 1.0]\np = 2.0\nprobN = NonlinearProblem{false}(f, u0, p)\nsolver = solve(probN, NewtonRaphson(), reltol = 1e-9)","category":"page"},{"location":"tutorials/nonlinear/","page":"Solving Nonlinear Systems","title":"Solving Nonlinear Systems","text":"where u0 is the initial condition for the rootfinder. Native NonlinearSolve.jl solvers use the given type of u0 to determine the type used within the solver and the return. Note that the parameters p can be any type, but most are an AbstractArray for automatic differentiation.","category":"page"},{"location":"tutorials/nonlinear/#Using-Bracketing-Methods","page":"Solving Nonlinear Systems","title":"Using Bracketing Methods","text":"","category":"section"},{"location":"tutorials/nonlinear/","page":"Solving Nonlinear Systems","title":"Solving Nonlinear Systems","text":"For scalar rootfinding problems, bracketing methods exist. In this case, one passes a bracket instead of an initial condition, for example:","category":"page"},{"location":"tutorials/nonlinear/","page":"Solving Nonlinear Systems","title":"Solving Nonlinear Systems","text":"using NonlinearSolve\nf(u, p) = u * u - 2.0\nuspan = (1.0, 2.0) # brackets\nprobB = IntervalNonlinearProblem(f, uspan)\nsol = solve(probB, Falsi())","category":"page"},{"location":"#NonlinearSolve.jl:-High-Performance-Unified-Nonlinear-Solvers","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"","category":"section"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"NonlinearSolve.jl is a unified interface for the nonlinear solving packages of Julia. The package includes its own high-performance nonlinear solvers which include the ability to swap out to fast direct and iterative linear solvers, along with the ability to use sparse automatic differentiation for Jacobian construction and Jacobian-vector products. NonlinearSolve.jl interfaces with other packages of the Julia ecosystem to make it easy to test alternative solver packages and pass small types to control algorithm swapping. It also interfaces with the ModelingToolkit.jl world of symbolic modeling to allow for automatically generating high-performance code.","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"Performance is key: the current methods are made to be highly performant on scalar and statically sized small problems, with options for large-scale systems. If you run into any performance issues, please file an issue. Consult the NonlinearSystemSolvers page for information on how to import solvers from different packages.","category":"page"},{"location":"#Installation","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"Installation","text":"","category":"section"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"To install NonlinearSolve.jl, use the Julia package manager:","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"using Pkg\nPkg.add(\"NonlinearSolve\")","category":"page"},{"location":"#Contributing","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"Contributing","text":"","category":"section"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nOn the Julia Discourse forums\nSee also SciML Community page","category":"page"},{"location":"#Reproducibility","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"</details>","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"</details>","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"</details>","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"You can also download the\n<a href=\"","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"using TOML\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n       \"/assets/Manifest.toml\"","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"\">manifest</a> file and the\n<a href=\"","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"using TOML\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n       \"/assets/Project.toml\"","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"\">project</a> file.","category":"page"},{"location":"solvers/SteadyStateSolvers/#Steady-State-Solvers","page":"Steady State Solvers","title":"Steady State Solvers","text":"","category":"section"},{"location":"solvers/SteadyStateSolvers/","page":"Steady State Solvers","title":"Steady State Solvers","text":"solve(prob::SteadyStateProblem,alg;kwargs)","category":"page"},{"location":"solvers/SteadyStateSolvers/","page":"Steady State Solvers","title":"Steady State Solvers","text":"Solves for the steady states in the problem defined by prob using the algorithm alg. If no algorithm is given, a default algorithm will be chosen.","category":"page"},{"location":"solvers/SteadyStateSolvers/#Recommended-Methods","page":"Steady State Solvers","title":"Recommended Methods","text":"","category":"section"},{"location":"solvers/SteadyStateSolvers/","page":"Steady State Solvers","title":"Steady State Solvers","text":"Conversion to a NonlinearProblem is generally the fastest method. However, this will not guarantee the preferred root, and thus if the preferred root is required, then it's recommended that one uses DynamicSS. For DynamicSS, often an adaptive stiff solver, like a Rosenbrock or BDF method (Rodas5 or QNDF), is a good way to allow for very large time steps as the steady state approaches.","category":"page"},{"location":"solvers/SteadyStateSolvers/","page":"Steady State Solvers","title":"Steady State Solvers","text":"note: Note\nThe SteadyStateDiffEq.jl methods on a SteadyStateProblem respect the time definition in the nonlinear definition, i.e., u' = f(u,t) uses the correct values for t as the solution evolves. A conversion of a SteadyStateProblem to a NonlinearProblem replaces this with the nonlinear system u' = f(u,∞), and thus the direct SteadyStateProblem approach can give different answers (i.e., the correct unique fixed point) on ODEs with non-autonomous dynamics.","category":"page"},{"location":"solvers/SteadyStateSolvers/#Full-List-of-Methods","page":"Steady State Solvers","title":"Full List of Methods","text":"","category":"section"},{"location":"solvers/SteadyStateSolvers/#Conversion-to-NonlinearProblem","page":"Steady State Solvers","title":"Conversion to NonlinearProblem","text":"","category":"section"},{"location":"solvers/SteadyStateSolvers/","page":"Steady State Solvers","title":"Steady State Solvers","text":"Any SteadyStateProblem can be trivially converted to a NonlinearProblem via NonlinearProblem(prob::SteadyStateProblem). Using this approach, any of the solvers from the Nonlinear System Solvers page can be used.","category":"page"},{"location":"solvers/SteadyStateSolvers/#SteadyStateDiffEq.jl","page":"Steady State Solvers","title":"SteadyStateDiffEq.jl","text":"","category":"section"},{"location":"solvers/SteadyStateSolvers/","page":"Steady State Solvers","title":"Steady State Solvers","text":"SteadyStateDiffEq.jl uses ODE solvers to iteratively approach the steady state. It is a very stable method for solving nonlinear systems, though often computationally more expensive than direct methods.","category":"page"},{"location":"solvers/SteadyStateSolvers/","page":"Steady State Solvers","title":"Steady State Solvers","text":"DynamicSS : Uses an ODE solver to find the steady state. Automatically terminates when close to the steady state. DynamicSS(alg;abstol=1e-8,reltol=1e-6,tspan=Inf) requires that an ODE algorithm is given as the first argument.  The absolute and relative tolerances specify the termination conditions on the derivative's closeness to zero.  This internally uses the TerminateSteadyState callback from the Callback Library.  The simulated time, for which the ODE is solved, can be limited by tspan.  If tspan is a number, it is equivalent to passing (zero(tspan), tspan).","category":"page"},{"location":"solvers/SteadyStateSolvers/","page":"Steady State Solvers","title":"Steady State Solvers","text":"Example usage:","category":"page"},{"location":"solvers/SteadyStateSolvers/","page":"Steady State Solvers","title":"Steady State Solvers","text":"using NonlinearSolve, SteadyStateDiffEq, OrdinaryDiffEq\nsol = solve(prob, DynamicSS(Tsit5()))\n\nusing Sundials\nsol = solve(prob, DynamicSS(CVODE_BDF()), dt = 1.0)","category":"page"},{"location":"solvers/SteadyStateSolvers/","page":"Steady State Solvers","title":"Steady State Solvers","text":"note: Note\nIf you use CVODE_BDF you may need to give a starting dt via dt=.....*","category":"page"}]
}
