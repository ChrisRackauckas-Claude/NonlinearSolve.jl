<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Nonlinear System Solvers · NonlinearSolve.jl</title><meta name="title" content="Nonlinear System Solvers · NonlinearSolve.jl"/><meta property="og:title" content="Nonlinear System Solvers · NonlinearSolve.jl"/><meta property="twitter:title" content="Nonlinear System Solvers · NonlinearSolve.jl"/><meta name="description" content="Documentation for NonlinearSolve.jl."/><meta property="og:description" content="Documentation for NonlinearSolve.jl."/><meta property="twitter:description" content="Documentation for NonlinearSolve.jl."/><meta property="og:url" content="https://docs.sciml.ai/NonlinearSolve/stable/solvers/NonlinearSystemSolvers/"/><meta property="twitter:url" content="https://docs.sciml.ai/NonlinearSolve/stable/solvers/NonlinearSystemSolvers/"/><link rel="canonical" href="https://docs.sciml.ai/NonlinearSolve/stable/solvers/NonlinearSystemSolvers/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="NonlinearSolve.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NonlinearSolve.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers</a></li><li><a class="tocitem" href="../../tutorials/getting_started/">Getting Started with Nonlinear Rootfinding in Julia</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/code_optimization/">Code Optimization for Small Nonlinear Systems in Julia</a></li><li><a class="tocitem" href="../../tutorials/large_systems/">Efficiently Solving Large Sparse Ill-Conditioned Nonlinear Systems in Julia</a></li><li><a class="tocitem" href="../../tutorials/modelingtoolkit/">Symbolic Nonlinear System Definition and Acceleration via ModelingToolkit</a></li><li><a class="tocitem" href="../../tutorials/small_compile/">Faster Startup and and Static Compilation</a></li><li><a class="tocitem" href="../../tutorials/iterator_interface/">Nonlinear Solver Iterator Interface</a></li><li><a class="tocitem" href="../../tutorials/optimizing_parameterized_ode/">Optimizing a Parameterized ODE</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/NonlinearProblem/">Nonlinear Problems</a></li><li><a class="tocitem" href="../../basics/NonlinearFunctions/">NonlinearFunctions and Jacobian Types</a></li><li><a class="tocitem" href="../../basics/solve/">Common Solver Options (Solve Keyword Arguments)</a></li><li><a class="tocitem" href="../../basics/NonlinearSolution/">Nonlinear Solutions</a></li><li><a class="tocitem" href="../../basics/TerminationCondition/">Termination Conditions</a></li><li><a class="tocitem" href="../../basics/Logging/">Logging the Solve Process</a></li><li><a class="tocitem" href="../../basics/SparsityDetection/">(Semi-)Automatic Sparsity Detection</a></li><li><a class="tocitem" href="../../basics/FAQ/">Frequently Asked Questions</a></li></ul></li><li><span class="tocitem">Solver Summaries and Recommendations</span><ul><li class="is-active"><a class="tocitem" href>Nonlinear System Solvers</a><ul class="internal"><li><a class="tocitem" href="#Recommended-Methods"><span>Recommended Methods</span></a></li><li><a class="tocitem" href="#Full-List-of-Methods"><span>Full List of Methods</span></a></li></ul></li><li><a class="tocitem" href="../BracketingSolvers/">Interval Rootfinding Methods (Bracketing Solvers)</a></li><li><a class="tocitem" href="../SteadyStateSolvers/">Steady State Solvers</a></li><li><a class="tocitem" href="../NonlinearLeastSquaresSolvers/">Nonlinear Least Squares Solvers</a></li><li><a class="tocitem" href="../LineSearch/">Line Search</a></li></ul></li><li><span class="tocitem">Detailed Solver APIs</span><ul><li><a class="tocitem" href="../../api/nonlinearsolve/">NonlinearSolve.jl Native Solvers</a></li><li><a class="tocitem" href="../../api/simplenonlinearsolve/">SimpleNonlinearSolve.jl</a></li><li><a class="tocitem" href="../../api/minpack/">MINPACK.jl</a></li><li><a class="tocitem" href="../../api/nlsolve/">NLsolve.jl</a></li><li><a class="tocitem" href="../../api/sundials/">Sundials.jl</a></li><li><a class="tocitem" href="../../api/steadystatediffeq/">SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../api/leastsquaresoptim/">LeastSquaresOptim.jl</a></li><li><a class="tocitem" href="../../api/fastlevenbergmarquardt/">FastLevenbergMarquardt.jl</a></li></ul></li><li><a class="tocitem" href="../../release_notes/">Release Notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solver Summaries and Recommendations</a></li><li class="is-active"><a href>Nonlinear System Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Nonlinear System Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/NonlinearSolve.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/NonlinearSolve.jl/blob/master/docs/src/solvers/NonlinearSystemSolvers.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="nonlinearsystemsolvers"><a class="docs-heading-anchor" href="#nonlinearsystemsolvers">Nonlinear System Solvers</a><a id="nonlinearsystemsolvers-1"></a><a class="docs-heading-anchor-permalink" href="#nonlinearsystemsolvers" title="Permalink"></a></h1><p><code>solve(prob::NonlinearProblem,alg;kwargs)</code></p><p>Solves for <span>$f(u)=0$</span> in the problem defined by <code>prob</code> using the algorithm <code>alg</code>. If no algorithm is given, a default algorithm will be chosen.</p><h2 id="Recommended-Methods"><a class="docs-heading-anchor" href="#Recommended-Methods">Recommended Methods</a><a id="Recommended-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Recommended-Methods" title="Permalink"></a></h2><p>The default method <code>FastShortcutNonlinearPolyalg</code> is a good choice for most problems. It is a polyalgorithm that attempts to use a fast algorithm (Klement, Broyden) and if that fails it falls back to a more robust algorithm (<code>NewtonRaphson</code>) before falling back the most robust variant of <code>TrustRegion</code>. For basic problems this will be very fast, for harder problems it will make sure to work.</p><p>If one is looking for more robustness then <code>RobustMultiNewton</code> is a good choice. It attempts a set of the most robust methods in succession and only fails if all of the methods fail to converge. Additionally, <code>DynamicSS</code> can be a good choice for high stability.</p><p>As a balance, <code>NewtonRaphson</code> is a good choice for most problems that aren&#39;t too difficult yet need high performance, and  <code>TrustRegion</code> is a bit less performant but more stable. If the problem is well-conditioned, <code>Klement</code> or <code>Broyden</code> may be faster, but highly dependent on the eigenvalues of the Jacobian being sufficiently small.</p><p><code>NewtonRaphson</code> and <code>TrustRegion</code> are designed for for large systems. They can make use of sparsity patterns for sparse automatic differentiation and sparse linear solving of very large systems. Meanwhile, <code>SimpleNewtonRaphson</code> and <code>SimpleTrustRegion</code> are implementations which are specialized for small equations. They are non-allocating on static arrays and thus really well-optimized for small systems, thus usually outperforming the other methods when such types are used for <code>u0</code>.</p><h2 id="Full-List-of-Methods"><a class="docs-heading-anchor" href="#Full-List-of-Methods">Full List of Methods</a><a id="Full-List-of-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Full-List-of-Methods" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For the full details on the capabilities and constructors of the different solvers, see the Detailed Solver APIs section!</p></div></div><h3 id="NonlinearSolve.jl"><a class="docs-heading-anchor" href="#NonlinearSolve.jl">NonlinearSolve.jl</a><a id="NonlinearSolve.jl-1"></a><a class="docs-heading-anchor-permalink" href="#NonlinearSolve.jl" title="Permalink"></a></h3><p>These are the core solvers, which excel at large-scale problems that need advanced linear solver, automatic differentiation, abstract array types, GPU, sparse/structured matrix support, etc. These methods support the largest set of types and features, but have a bit of overhead on very small problems.</p><ul><li><code>NewtonRaphson()</code>:A Newton-Raphson method with swappable nonlinear solvers and autodiff methods for high performance on large and sparse systems.</li><li><code>TrustRegion()</code>: A Newton Trust Region dogleg method with swappable nonlinear solvers and autodiff methods for high performance on large and sparse systems.</li><li><code>LevenbergMarquardt()</code>: An advanced Levenberg-Marquardt implementation with the improvements suggested in the <a href="https://arxiv.org/abs/1201.5885">paper</a> &quot;Improvements to the Levenberg-Marquardt algorithm for nonlinear least-squares minimization&quot;. Designed for large-scale and numerically-difficult nonlinear systems.</li><li><code>PseudoTransient()</code>: A pseudo-transient method which mixes the stability of Euler-type stepping with the convergence speed of a Newton method. Good for highly unstable systems.</li><li><code>RobustMultiNewton()</code>: A polyalgorithm that mixes highly robust methods (line searches and trust regions) in order to be as robust as possible for difficult problems. If this method fails to converge, then one can be pretty certain that most (all?) other choices would likely fail.</li><li><code>FastShortcutNonlinearPolyalg()</code>: The default method. A polyalgorithm that mixes fast methods with fallbacks to robust methods to allow for solving easy problems quickly without sacrificing robustness on the hard problems.</li><li><code>Broyden()</code>: Generalization of Broyden&#39;s Quasi-Newton Method with Line Search and Automatic Jacobian Resetting. This is a fast method but unstable when the condition number of the Jacobian matrix is sufficiently large.</li><li><code>Klement()</code>: Generalization of Klement&#39;s Quasi-Newton Method with Line Search and Automatic Jacobian Resetting. This is a fast method but unstable when the condition number of the Jacobian matrix is sufficiently large.</li><li><code>LimitedMemoryBroyden()</code>: An advanced version of <code>LBroyden</code> which uses a limited memory Broyden method. This is a fast method but unstable when the condition number of the Jacobian matrix is sufficiently large. It is recommended to use <code>Broyden</code> or <code>Klement</code> instead unless the memory usage is a concern.</li></ul><h3 id="SimpleNonlinearSolve.jl"><a class="docs-heading-anchor" href="#SimpleNonlinearSolve.jl">SimpleNonlinearSolve.jl</a><a id="SimpleNonlinearSolve.jl-1"></a><a class="docs-heading-anchor-permalink" href="#SimpleNonlinearSolve.jl" title="Permalink"></a></h3><p>These methods are included with NonlinearSolve.jl by default, though SimpleNonlinearSolve.jl can be used directly to reduce dependencies and improve load times. SimpleNonlinearSolve.jl&#39;s methods excel at small problems and problems defined with static arrays.</p><ul><li><code>SimpleNewtonRaphson()</code>: A simplified implementation of the Newton-Raphson method.</li><li><code>SimpleBroyden()</code>: The classic Broyden&#39;s quasi-Newton method.</li><li><code>SimpleLimitedMemoryBroyden()</code>: A low-memory Broyden implementation, similar to L-BFGS. This method is common in machine learning contexts but is known to be unstable in comparison to many other choices.</li><li><code>SimpleKlement()</code>: A quasi-Newton method due to Klement. It&#39;s supposed to be more efficient than Broyden&#39;s method, and it seems to be in the cases that have been tried, but more benchmarking is required.</li><li><code>SimpleTrustRegion()</code>: A dogleg trust-region Newton method. Improved globalizing stability for more robust fitting over basic Newton methods, though potentially with a cost.</li><li><code>SimpleDFSane()</code>: A low-overhead implementation of the df-sane method for solving large-scale nonlinear systems of equations.</li><li><code>SimpleHalley()</code>: A low-overhead implementation of the Halley method. This is a higher order method and thus can converge faster to low tolerances than a Newton method. Requires higher order derivatives, so best used when automatic differentiation is available.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When used with certain types for the states <code>u</code> such as a <code>Number</code> or <code>StaticArray</code>, these solvers are very efficient and non-allocating. These implementations are thus well-suited for small systems of equations.</p></div></div><h3 id="SteadyStateDiffEq.jl"><a class="docs-heading-anchor" href="#SteadyStateDiffEq.jl">SteadyStateDiffEq.jl</a><a id="SteadyStateDiffEq.jl-1"></a><a class="docs-heading-anchor-permalink" href="#SteadyStateDiffEq.jl" title="Permalink"></a></h3><p>SteadyStateDiffEq.jl uses ODE solvers to iteratively approach the steady state. It is a very stable method for solving nonlinear systems, though often more computationally expensive than direct methods.</p><ul><li><code>DynamicSS()</code>: Uses an ODE solver to find the steady state. Automatically terminates when close to the steady state.</li><li><code>SSRootfind()</code>: Uses a NonlinearSolve compatible solver to find the steady state.</li></ul><h3 id="NLsolve.jl"><a class="docs-heading-anchor" href="#NLsolve.jl">NLsolve.jl</a><a id="NLsolve.jl-1"></a><a class="docs-heading-anchor-permalink" href="#NLsolve.jl" title="Permalink"></a></h3><p>This is a wrapper package for importing solvers from NLsolve.jl into the SciML interface.</p><ul><li><code>NLsolveJL()</code>: A wrapper for <a href="https://github.com/JuliaNLSolvers/NLsolve.jl">NLsolve.jl</a></li></ul><p>Submethod choices for this algorithm include:</p><ul><li><code>:anderson</code>: Anderson-accelerated fixed-point iteration</li><li><code>:newton</code>: Classical Newton method with an optional line search</li><li><code>:trust_region</code>: Trust region Newton method (the default choice)</li></ul><h3 id="MINPACK.jl"><a class="docs-heading-anchor" href="#MINPACK.jl">MINPACK.jl</a><a id="MINPACK.jl-1"></a><a class="docs-heading-anchor-permalink" href="#MINPACK.jl" title="Permalink"></a></h3><p>MINPACK.jl methods are good for medium-sized nonlinear solves. It does not scale due to the lack of sparse Jacobian support, though the methods are very robust and stable.</p><ul><li><code>CMINPACK()</code>: A wrapper for using the classic MINPACK method through <a href="https://github.com/sglyon/MINPACK.jl">MINPACK.jl</a></li></ul><p>Submethod choices for this algorithm include:</p><ul><li><code>:hybr</code>: Modified version of Powell&#39;s algorithm.</li><li><code>:lm</code>: Levenberg-Marquardt.</li><li><code>:lmdif</code>: Advanced Levenberg-Marquardt</li><li><code>:hybrd</code>: Advanced modified version of Powell&#39;s algorithm</li></ul><h3 id="Sundials.jl"><a class="docs-heading-anchor" href="#Sundials.jl">Sundials.jl</a><a id="Sundials.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Sundials.jl" title="Permalink"></a></h3><p>Sundials.jl are a classic set of C/Fortran methods which are known for good scaling of the Newton-Krylov form. However, KINSOL is known to be less stable than some other implementations, as it has no line search or globalizer (trust region).</p><ul><li><code>KINSOL()</code>: The KINSOL method of the SUNDIALS C library</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../basics/FAQ/">« Frequently Asked Questions</a><a class="docs-footer-nextpage" href="../BracketingSolvers/">Interval Rootfinding Methods (Bracketing Solvers) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 18 December 2023 12:17">Monday 18 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
