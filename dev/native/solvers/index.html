<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>NonlinearSolve.jl Solvers · NonlinearSolve.jl</title><meta name="title" content="NonlinearSolve.jl Solvers · NonlinearSolve.jl"/><meta property="og:title" content="NonlinearSolve.jl Solvers · NonlinearSolve.jl"/><meta property="twitter:title" content="NonlinearSolve.jl Solvers · NonlinearSolve.jl"/><meta name="description" content="Documentation for NonlinearSolve.jl."/><meta property="og:description" content="Documentation for NonlinearSolve.jl."/><meta property="twitter:description" content="Documentation for NonlinearSolve.jl."/><meta property="og:url" content="https://docs.sciml.ai/NonlinearSolve/stable/native/solvers/"/><meta property="twitter:url" content="https://docs.sciml.ai/NonlinearSolve/stable/native/solvers/"/><link rel="canonical" href="https://docs.sciml.ai/NonlinearSolve/stable/native/solvers/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="NonlinearSolve.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NonlinearSolve.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers</a></li><li><a class="tocitem" href="../../tutorials/getting_started/">Getting Started with Nonlinear Rootfinding in Julia</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/code_optimization/">Code Optimization for Small Nonlinear Systems in Julia</a></li><li><a class="tocitem" href="../../tutorials/large_systems/">Efficiently Solving Large Sparse Ill-Conditioned Nonlinear Systems in Julia</a></li><li><a class="tocitem" href="../../tutorials/modelingtoolkit/">Symbolic Nonlinear System Definition and Acceleration via ModelingToolkit</a></li><li><a class="tocitem" href="../../tutorials/small_compile/">Faster Startup and and Static Compilation</a></li><li><a class="tocitem" href="../../tutorials/iterator_interface/">Nonlinear Solver Iterator Interface</a></li><li><a class="tocitem" href="../../tutorials/optimizing_parameterized_ode/">Optimizing a Parameterized ODE</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/nonlinear_problem/">Nonlinear Problems</a></li><li><a class="tocitem" href="../../basics/nonlinear_functions/">Nonlinear Functions and Jacobian Types</a></li><li><a class="tocitem" href="../../basics/solve/">Common Solver Options (Solve Keyword Arguments)</a></li><li><a class="tocitem" href="../../basics/nonlinear_solution/">Nonlinear Solutions</a></li><li><a class="tocitem" href="../../basics/autodiff/">Automatic Differentiation Backends</a></li><li><a class="tocitem" href="../../basics/termination_condition/">Termination Conditions</a></li><li><a class="tocitem" href="../../basics/diagnostics_api/">Diagnostics API</a></li><li><a class="tocitem" href="../../basics/sparsity_detection/">(Semi-)Automatic Sparsity Detection</a></li><li><a class="tocitem" href="../../basics/faq/">Frequently Asked Questions</a></li></ul></li><li><span class="tocitem">Solver Summaries and Recommendations</span><ul><li><a class="tocitem" href="../../solvers/nonlinear_system_solvers/">Nonlinear System Solvers</a></li><li><a class="tocitem" href="../../solvers/bracketing_solvers/">Interval Root-Finding Methods (Bracketing Solvers)</a></li><li><a class="tocitem" href="../../solvers/steady_state_solvers/">Steady State Solvers</a></li><li><a class="tocitem" href="../../solvers/nonlinear_least_squares_solvers/">Nonlinear Least Squares Solvers</a></li><li><a class="tocitem" href="../../solvers/fixed_point_solvers/">Fixed Point Solvers</a></li></ul></li><li><span class="tocitem">Native Functionalities</span><ul><li class="is-active"><a class="tocitem" href>NonlinearSolve.jl Solvers</a><ul class="internal"><li><a class="tocitem" href="#General-Keyword-Arguments"><span>General Keyword Arguments</span></a></li><li><a class="tocitem" href="#Nonlinear-Solvers"><span>Nonlinear Solvers</span></a></li><li><a class="tocitem" href="#Nonlinear-Least-Squares-Solvers"><span>Nonlinear Least Squares Solvers</span></a></li><li><a class="tocitem" href="#Both-Nonlinear-and-Nonlinear-Least-Squares-Solvers"><span>Both Nonlinear &amp; Nonlinear Least Squares Solvers</span></a></li><li><a class="tocitem" href="#Polyalgorithms"><span>Polyalgorithms</span></a></li><li><a class="tocitem" href="#Advanced-Solvers"><span>Advanced Solvers</span></a></li></ul></li><li><a class="tocitem" href="../simplenonlinearsolve/">SimpleNonlinearSolve.jl</a></li><li><a class="tocitem" href="../steadystatediffeq/">SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../descent/">Descent Subroutines</a></li><li><a class="tocitem" href="../globalization/">Globalization Subroutines</a></li><li><a class="tocitem" href="../diagnostics/">Diagnostics API</a></li></ul></li><li><span class="tocitem">Wrapped Solver APIs</span><ul><li><a class="tocitem" href="../../api/fastlevenbergmarquardt/">FastLevenbergMarquardt.jl</a></li><li><a class="tocitem" href="../../api/fixedpointacceleration/">FixedPointAcceleration.jl</a></li><li><a class="tocitem" href="../../api/leastsquaresoptim/">LeastSquaresOptim.jl</a></li><li><a class="tocitem" href="../../api/minpack/">MINPACK.jl</a></li><li><a class="tocitem" href="../../api/nlsolve/">NLsolve.jl</a></li><li><a class="tocitem" href="../../api/nlsolvers/">NLSolvers.jl</a></li><li><a class="tocitem" href="../../api/siamfanlequations/">SIAMFANLEquations.jl</a></li><li><a class="tocitem" href="../../api/speedmapping/">SpeedMapping.jl</a></li><li><a class="tocitem" href="../../api/sundials/">Sundials.jl</a></li></ul></li><li><span class="tocitem">Development Documentation</span><ul><li><a class="tocitem" href="../../devdocs/internal_interfaces/">Internal Abstract Types</a></li><li><a class="tocitem" href="../../devdocs/linear_solve/">Linear Solve</a></li><li><a class="tocitem" href="../../devdocs/jacobian/">Jacobian Wrappers</a></li><li><a class="tocitem" href="../../devdocs/operators/">Custom SciML Operators</a></li><li><a class="tocitem" href="../../devdocs/algorithm_helpers/">Internal Algorithm Helpers</a></li></ul></li><li><a class="tocitem" href="../../release_notes/">Release Notes</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Native Functionalities</a></li><li class="is-active"><a href>NonlinearSolve.jl Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>NonlinearSolve.jl Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/NonlinearSolve.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/NonlinearSolve.jl/blob/master/docs/src/native/solvers.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="NonlinearSolve.jl-Solvers"><a class="docs-heading-anchor" href="#NonlinearSolve.jl-Solvers">NonlinearSolve.jl Solvers</a><a id="NonlinearSolve.jl-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#NonlinearSolve.jl-Solvers" title="Permalink"></a></h1><p>These are the native solvers of NonlinearSolve.jl.</p><ul><li><a href="#NonlinearSolve.ApproximateJacobianSolveAlgorithm"><code>NonlinearSolve.ApproximateJacobianSolveAlgorithm</code></a></li><li><a href="#NonlinearSolve.GeneralizedDFSane"><code>NonlinearSolve.GeneralizedDFSane</code></a></li><li><a href="#NonlinearSolve.GeneralizedFirstOrderAlgorithm"><code>NonlinearSolve.GeneralizedFirstOrderAlgorithm</code></a></li><li><a href="#NonlinearSolve.NonlinearSolvePolyAlgorithm"><code>NonlinearSolve.NonlinearSolvePolyAlgorithm</code></a></li><li><a href="#NonlinearSolve.Broyden"><code>NonlinearSolve.Broyden</code></a></li><li><a href="#NonlinearSolve.DFSane"><code>NonlinearSolve.DFSane</code></a></li><li><a href="#NonlinearSolve.FastShortcutNLLSPolyalg"><code>NonlinearSolve.FastShortcutNLLSPolyalg</code></a></li><li><a href="#NonlinearSolve.FastShortcutNonlinearPolyalg"><code>NonlinearSolve.FastShortcutNonlinearPolyalg</code></a></li><li><a href="#NonlinearSolve.GaussNewton"><code>NonlinearSolve.GaussNewton</code></a></li><li><a href="#NonlinearSolve.Klement"><code>NonlinearSolve.Klement</code></a></li><li><a href="#NonlinearSolve.LevenbergMarquardt"><code>NonlinearSolve.LevenbergMarquardt</code></a></li><li><a href="#NonlinearSolve.LimitedMemoryBroyden"><code>NonlinearSolve.LimitedMemoryBroyden</code></a></li><li><a href="#NonlinearSolve.NewtonRaphson"><code>NonlinearSolve.NewtonRaphson</code></a></li><li><a href="#NonlinearSolve.PseudoTransient"><code>NonlinearSolve.PseudoTransient</code></a></li><li><a href="#NonlinearSolve.RobustMultiNewton"><code>NonlinearSolve.RobustMultiNewton</code></a></li><li><a href="#NonlinearSolve.TrustRegion"><code>NonlinearSolve.TrustRegion</code></a></li></ul><h2 id="General-Keyword-Arguments"><a class="docs-heading-anchor" href="#General-Keyword-Arguments">General Keyword Arguments</a><a id="General-Keyword-Arguments-1"></a><a class="docs-heading-anchor-permalink" href="#General-Keyword-Arguments" title="Permalink"></a></h2><p>Several Algorithms share the same specification for common keyword arguments. Those are documented in this section to avoid repetition. Certain algorithms might have additional considerations for these keyword arguments, which are documented in the algorithm&#39;s documentation.</p><ul><li><code>linsolve</code>: the <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> solvers used for the linear solves within the Newton method. Defaults to <code>nothing</code>, which means it uses the LinearSolve.jl default algorithm choice. For more information on available algorithm choices, see the <a href="https://docs.sciml.ai/LinearSolve/stable/">LinearSolve.jl documentation</a>.</li><li><code>precs</code>: the choice of preconditioners for the linear solver. Defaults to using no preconditioners. For more information on specifying preconditioners for LinearSolve algorithms, consult the <a href="https://docs.sciml.ai/LinearSolve/stable/">LinearSolve.jl documentation</a>.</li><li><code>linesearch</code>: the line search algorithm to use. Defaults to <a href="../globalization/#NonlinearSolve.NoLineSearch"><code>NoLineSearch()</code></a>, which means that no line search is performed.  Algorithms from <a href="https://github.com/JuliaNLSolvers/LineSearches.jl/"><code>LineSearches.jl</code></a> must be wrapped in <a href="../globalization/#NonlinearSolve.LineSearchesJL"><code>LineSearchesJL</code></a> before being supplied. For a detailed documentation refer to <a href="../globalization/#line-search">Line Search Algorithms</a>.</li><li><code>autodiff</code>/<code>jacobian_ad</code>: etermines the backend used for the Jacobian. Note that this argument is ignored if an analytical Jacobian is passed, as that will be used instead. Defaults to <code>nothing</code> which means that a default is selected according to the problem specification! Valid choices are types from ADTypes.jl.</li><li><code>forward_ad</code>/<code>vjp_autodiff</code>: similar to <code>autodiff</code>, but is used to compute Jacobian Vector Products. Ignored if the NonlinearFunction contains the <code>jvp</code> function.</li><li><code>reverse_ad</code>/<code>vjp_autodiff</code>: similar to <code>autodiff</code>, but is used to compute Vector Jacobian Products. Ignored if the NonlinearFunction contains the <code>vjp</code> function.</li><li><code>concrete_jac</code>: whether to build a concrete Jacobian. If a Krylov-subspace method is used, then the Jacobian will not be constructed and instead direct Jacobian-Vector products <code>J*v</code> are computed using forward-mode automatic differentiation or finite differencing tricks (without ever constructing the Jacobian). However, if the Jacobian is still needed, for example for a preconditioner, <code>concrete_jac = true</code> can be passed in order to force the construction of the Jacobian.</li></ul><h2 id="Nonlinear-Solvers"><a class="docs-heading-anchor" href="#Nonlinear-Solvers">Nonlinear Solvers</a><a id="Nonlinear-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-Solvers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.NewtonRaphson" href="#NonlinearSolve.NewtonRaphson"><code>NonlinearSolve.NewtonRaphson</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">NewtonRaphson(; concrete_jac = nothing, linsolve = nothing, linesearch = NoLineSearch(),
    precs = DEFAULT_PRECS, autodiff = nothing)</code></pre><p>An advanced NewtonRaphson implementation with support for efficient handling of sparse matrices via colored automatic differentiation and preconditioned linear solvers. Designed for large-scale and numerically-difficult nonlinear systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/9a0bb8d22fdeeeeca84cedd93357578f3dac2264/src/algorithms/raphson.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.DFSane" href="#NonlinearSolve.DFSane"><code>NonlinearSolve.DFSane</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">DFSane(; σ_min = 1 // 10^10, σ_max = 1e10, σ_1 = 1, M::Int = 10, γ = 1 // 10^4,
    τ_min = 1 // 10, τ_max = 1 // 2, n_exp::Int = 2, max_inner_iterations::Int = 100,
    η_strategy = (fn_1, n, x_n, f_n) -&gt; fn_1 / n^2)</code></pre><p>A low-overhead and allocation-free implementation of the df-sane method for solving large-scale nonlinear systems of equations. For in depth information about all the parameters and the algorithm, see <a href="../../references/#la2006spectral">La Cruz <em>et al.</em> [2]</a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>σ_min</code>: the minimum value of the spectral coefficient <code>σₙ</code> which is related to the step size in the algorithm. Defaults to <code>1e-10</code>.</li><li><code>σ_max</code>: the maximum value of the spectral coefficient <code>σₙ</code> which is related to the step size in the algorithm. Defaults to <code>1e10</code>.</li></ul><p>For other keyword arguments, see <a href="../globalization/#NonlinearSolve.RobustNonMonotoneLineSearch"><code>RobustNonMonotoneLineSearch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/9a0bb8d22fdeeeeca84cedd93357578f3dac2264/src/algorithms/dfsane.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.Broyden" href="#NonlinearSolve.Broyden"><code>NonlinearSolve.Broyden</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Broyden(; max_resets::Int = 100, linesearch = NoLineSearch(), reset_tolerance = nothing,
    init_jacobian::Val = Val(:identity), autodiff = nothing, alpha = nothing)</code></pre><p>An implementation of <code>Broyden</code>&#39;s Method [<a href="../../references/#broyden1965class">3</a>] with resetting and line search.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>max_resets</code>: the maximum number of resets to perform. Defaults to <code>100</code>.</p></li><li><p><code>reset_tolerance</code>: the tolerance for the reset check. Defaults to <code>sqrt(eps(real(eltype(u))))</code>.</p></li><li><p><code>alpha</code>: If <code>init_jacobian</code> is set to <code>Val(:identity)</code>, then the initial Jacobian inverse is set to be <code>(αI)⁻¹</code>. Defaults to <code>nothing</code> which implies <code>α = max(norm(u), 1) / (2 * norm(fu))</code>.</p></li><li><p><code>init_jacobian</code>: the method to use for initializing the jacobian. Defaults to <code>Val(:identity)</code>. Choices include:</p><ul><li><code>Val(:identity)</code>: Identity Matrix.</li><li><code>Val(:true_jacobian)</code>: True Jacobian. This is a good choice for differentiable problems.</li></ul></li><li><p><code>update_rule</code>: Update Rule for the Jacobian. Choices are:</p><ul><li><code>Val(:good_broyden)</code>: Good Broyden&#39;s Update Rule</li><li><code>Val(:bad_broyden)</code>: Bad Broyden&#39;s Update Rule</li><li><code>Val(:diagonal)</code>: Only update the diagonal of the Jacobian. This algorithm may be useful for specific problems, but whether it will work may depend strongly on the problem</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/9a0bb8d22fdeeeeca84cedd93357578f3dac2264/src/algorithms/broyden.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.Klement" href="#NonlinearSolve.Klement"><code>NonlinearSolve.Klement</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Klement(; max_resets = 100, linsolve = NoLineSearch(), linesearch = nothing,
    precs = DEFAULT_PRECS, alpha = nothing, init_jacobian::Val = Val(:identity),
    autodiff = nothing)</code></pre><p>An implementation of <code>Klement</code> [<a href="../../references/#klement2014using">4</a>] with line search, preconditioning and customizable linear solves. It is recommended to use <a href="#NonlinearSolve.Broyden"><code>Broyden</code></a> for most problems over this.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>max_resets</code>: the maximum number of resets to perform. Defaults to <code>100</code>.</p></li><li><p><code>alpha</code>: If <code>init_jacobian</code> is set to <code>Val(:identity)</code>, then the initial Jacobian inverse is set to be <code>αI</code>. Defaults to <code>1</code>. Can be set to <code>nothing</code> which implies <code>α = max(norm(u), 1) / (2 * norm(fu))</code>.</p></li><li><p><code>init_jacobian</code>: the method to use for initializing the jacobian. Defaults to <code>Val(:identity)</code>. Choices include:</p><ul><li><code>Val(:identity)</code>: Identity Matrix.</li><li><code>Val(:true_jacobian)</code>: True Jacobian. Our tests suggest that this is not very stable. Instead using <code>Broyden</code> with <code>Val(:true_jacobian)</code> gives faster and more reliable convergence.</li><li><code>Val(:true_jacobian_diagonal)</code>: Diagonal of True Jacobian. This is a good choice for differentiable problems.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/9a0bb8d22fdeeeeca84cedd93357578f3dac2264/src/algorithms/klement.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.LimitedMemoryBroyden" href="#NonlinearSolve.LimitedMemoryBroyden"><code>NonlinearSolve.LimitedMemoryBroyden</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LimitedMemoryBroyden(; max_resets::Int = 3, linesearch = NoLineSearch(),
    threshold::Val = Val(10), reset_tolerance = nothing, alpha = nothing)</code></pre><p>An implementation of <code>LimitedMemoryBroyden</code> [<a href="../../references/#ziani2008autoadaptative">5</a>] with resetting and line search.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>max_resets</code>: the maximum number of resets to perform. Defaults to <code>3</code>.</li><li><code>reset_tolerance</code>: the tolerance for the reset check. Defaults to <code>sqrt(eps(real(eltype(u))))</code>.</li><li><code>threshold</code>: the number of vectors to store in the low rank approximation. Defaults to <code>Val(10)</code>.</li><li><code>alpha</code>: The initial Jacobian inverse is set to be <code>(αI)⁻¹</code>. Defaults to <code>nothing</code> which implies <code>α = max(norm(u), 1) / (2 * norm(fu))</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/9a0bb8d22fdeeeeca84cedd93357578f3dac2264/src/algorithms/lbroyden.jl#L1-L17">source</a></section></article><h2 id="Nonlinear-Least-Squares-Solvers"><a class="docs-heading-anchor" href="#Nonlinear-Least-Squares-Solvers">Nonlinear Least Squares Solvers</a><a id="Nonlinear-Least-Squares-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-Least-Squares-Solvers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.GaussNewton" href="#NonlinearSolve.GaussNewton"><code>NonlinearSolve.GaussNewton</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">GaussNewton(; concrete_jac = nothing, linsolve = nothing, linesearch = NoLineSearch(),
    precs = DEFAULT_PRECS, adkwargs...)</code></pre><p>An advanced GaussNewton implementation with support for efficient handling of sparse matrices via colored automatic differentiation and preconditioned linear solvers. Designed for large-scale and numerically-difficult nonlinear least squares problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/9a0bb8d22fdeeeeca84cedd93357578f3dac2264/src/algorithms/gauss_newton.jl#L1-L8">source</a></section></article><h2 id="Both-Nonlinear-and-Nonlinear-Least-Squares-Solvers"><a class="docs-heading-anchor" href="#Both-Nonlinear-and-Nonlinear-Least-Squares-Solvers">Both Nonlinear &amp; Nonlinear Least Squares Solvers</a><a id="Both-Nonlinear-and-Nonlinear-Least-Squares-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Both-Nonlinear-and-Nonlinear-Least-Squares-Solvers" title="Permalink"></a></h2><p>These solvers can be used for both nonlinear and nonlinear least squares problems.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.TrustRegion" href="#NonlinearSolve.TrustRegion"><code>NonlinearSolve.TrustRegion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">TrustRegion(; concrete_jac = nothing, linsolve = nothing, precs = DEFAULT_PRECS,
    radius_update_scheme = RadiusUpdateSchemes.Simple, max_trust_radius::Real = 0 // 1,
    initial_trust_radius::Real = 0 // 1, step_threshold::Real = 1 // 10000,
    shrink_threshold::Real = 1 // 4, expand_threshold::Real = 3 // 4,
    shrink_factor::Real = 1 // 4, expand_factor::Real = 2 // 1,
    max_shrink_times::Int = 32, vjp_autodiff = nothing, autodiff = nothing)</code></pre><p>An advanced TrustRegion implementation with support for efficient handling of sparse matrices via colored automatic differentiation and preconditioned linear solvers. Designed for large-scale and numerically-difficult nonlinear systems.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>radius_update_scheme</code>: the scheme used to update the trust region radius. Defaults to <code>RadiusUpdateSchemes.Simple</code>. See <a href="../globalization/#NonlinearSolve.RadiusUpdateSchemes"><code>RadiusUpdateSchemes</code></a> for more details. For a review on trust region radius update schemes, see <a href="../../references/#yuan2015recent">Yuan [6]</a>.</li></ul><p>For the remaining arguments, see <a href="../../devdocs/algorithm_helpers/#NonlinearSolve.GenericTrustRegionScheme"><code>NonlinearSolve.GenericTrustRegionScheme</code></a> documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/9a0bb8d22fdeeeeca84cedd93357578f3dac2264/src/algorithms/trust_region.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.LevenbergMarquardt" href="#NonlinearSolve.LevenbergMarquardt"><code>NonlinearSolve.LevenbergMarquardt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LevenbergMarquardt(; linsolve = nothing,
    precs = DEFAULT_PRECS, damping_initial::Real = 1.0, α_geodesic::Real = 0.75,
    damping_increase_factor::Real = 2.0, damping_decrease_factor::Real = 3.0,
    finite_diff_step_geodesic = 0.1, b_uphill::Real = 1.0, autodiff = nothing,
    min_damping_D::Real = 1e-8, disable_geodesic = Val(false))</code></pre><p>An advanced Levenberg-Marquardt implementation with the improvements suggested in <a href="../../references/#transtrum2012improvements">Transtrum and Sethna [1]</a>. Designed for large-scale and numerically-difficult nonlinear systems.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>damping_initial</code>: the starting value for the damping factor. The damping factor is inversely proportional to the step size. The damping factor is adjusted during each iteration. Defaults to <code>1.0</code>. See Section 2.1 of <a href="../../references/#transtrum2012improvements">Transtrum and Sethna [1]</a>.</li><li><code>damping_increase_factor</code>: the factor by which the damping is increased if a step is rejected. Defaults to <code>2.0</code>. See Section 2.1 of <a href="../../references/#transtrum2012improvements">Transtrum and Sethna [1]</a>.</li><li><code>damping_decrease_factor</code>: the factor by which the damping is decreased if a step is accepted. Defaults to <code>3.0</code>. See Section 2.1 of <a href="../../references/#transtrum2012improvements">Transtrum and Sethna [1]</a>.</li><li><code>min_damping_D</code>: the minimum value of the damping terms in the diagonal damping matrix <code>DᵀD</code>, where <code>DᵀD</code> is given by the largest diagonal entries of <code>JᵀJ</code> yet encountered, where <code>J</code> is the Jacobian. It is suggested by <a href="../../references/#transtrum2012improvements">Transtrum and Sethna [1]</a> to use a minimum value of the elements in <code>DᵀD</code> to prevent the damping from being too small. Defaults to <code>1e-8</code>.</li><li><code>disable_geodesic</code>: Disables Geodesic Acceleration if set to <code>Val(true)</code>. It provides a way to trade-off robustness for speed, though in most situations Geodesic Acceleration should not be disabled.</li></ul><p>For the remaining arguments, see <a href="../descent/#NonlinearSolve.GeodesicAcceleration"><code>GeodesicAcceleration</code></a> and <a href="../../devdocs/algorithm_helpers/#NonlinearSolve.LevenbergMarquardtTrustRegion"><code>NonlinearSolve.LevenbergMarquardtTrustRegion</code></a> documentations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/9a0bb8d22fdeeeeca84cedd93357578f3dac2264/src/algorithms/levenberg_marquardt.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.PseudoTransient" href="#NonlinearSolve.PseudoTransient"><code>NonlinearSolve.PseudoTransient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">PseudoTransient(; concrete_jac = nothing, linsolve = nothing,
    linesearch::AbstractNonlinearSolveLineSearchAlgorithm = NoLineSearch(),
    precs = DEFAULT_PRECS, autodiff = nothing)</code></pre><p>An implementation of PseudoTransient Method [<a href="../../references/#coffey2003pseudotransient">7</a>] that is used to solve steady state problems in an accelerated manner. It uses an adaptive time-stepping to integrate an initial value of nonlinear problem until sufficient accuracy in the desired steady-state is achieved to switch over to Newton&#39;s method and gain a rapid convergence. This implementation specifically uses &quot;switched evolution relaxation&quot; [<a href="../../references/#kelley1998convergence">8</a>] SER method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>alpha_initial</code> : the initial pseudo time step. It defaults to <code>1e-3</code>. If it is small, you are going to need more iterations to converge but it can be more stable.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/9a0bb8d22fdeeeeca84cedd93357578f3dac2264/src/algorithms/pseudo_transient.jl#L1-L17">source</a></section></article><h2 id="Polyalgorithms"><a class="docs-heading-anchor" href="#Polyalgorithms">Polyalgorithms</a><a id="Polyalgorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Polyalgorithms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.NonlinearSolvePolyAlgorithm" href="#NonlinearSolve.NonlinearSolvePolyAlgorithm"><code>NonlinearSolve.NonlinearSolvePolyAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonlinearSolvePolyAlgorithm(algs, ::Val{pType} = Val(:NLS);
    start_index = 1) where {pType}</code></pre><p>A general way to define PolyAlgorithms for <code>NonlinearProblem</code> and <code>NonlinearLeastSquaresProblem</code>. This is a container for a tuple of algorithms that will be tried in order until one succeeds. If none succeed, then the algorithm with the lowest residual is returned.</p><p><strong>Arguments</strong></p><ul><li><code>algs</code>: a tuple of algorithms to try in-order! (If this is not a Tuple, then the returned algorithm is not type-stable).</li><li><code>pType</code>: the problem type. Defaults to <code>:NLS</code> for <code>NonlinearProblem</code> and <code>:NLLS</code> for <code>NonlinearLeastSquaresProblem</code>. This is used to determine the correct problem type to dispatch on.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>start_index</code>: the index to start at. Defaults to <code>1</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using NonlinearSolve

alg = NonlinearSolvePolyAlgorithm((NewtonRaphson(), Broyden()))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/9a0bb8d22fdeeeeca84cedd93357578f3dac2264/src/default.jl#L2-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.FastShortcutNonlinearPolyalg" href="#NonlinearSolve.FastShortcutNonlinearPolyalg"><code>NonlinearSolve.FastShortcutNonlinearPolyalg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FastShortcutNonlinearPolyalg(::Type{T} = Float64; concrete_jac = nothing,
    linsolve = nothing, precs = DEFAULT_PRECS, must_use_jacobian::Val = Val(false),
    prefer_simplenonlinearsolve::Val{SA} = Val(false), autodiff = nothing,
    u0_len::Union{Int, Nothing} = nothing) where {T}</code></pre><p>A polyalgorithm focused on balancing speed and robustness. It first tries less robust methods for more performance and then tries more robust techniques if the faster ones fail.</p><p><strong>Arguments</strong></p><ul><li><code>T</code>: The eltype of the initial guess. It is only used to check if some of the algorithms are compatible with the problem type. Defaults to <code>Float64</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>u0_len</code>: The length of the initial guess. If this is <code>nothing</code>, then the length of the initial guess is not checked. If this is an integer and it is less than <code>25</code>, we use jacobian based methods.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/9a0bb8d22fdeeeeca84cedd93357578f3dac2264/src/default.jl#L376-L395">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.FastShortcutNLLSPolyalg" href="#NonlinearSolve.FastShortcutNLLSPolyalg"><code>NonlinearSolve.FastShortcutNLLSPolyalg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FastShortcutNLLSPolyalg(::Type{T} = Float64; concrete_jac = nothing, linsolve = nothing,
    precs = DEFAULT_PRECS, autodiff = nothing, kwargs...)</code></pre><p>A polyalgorithm focused on balancing speed and robustness. It first tries less robust methods for more performance and then tries more robust techniques if the faster ones fail.</p><p><strong>Arguments</strong></p><ul><li><code>T</code>: The eltype of the initial guess. It is only used to check if some of the algorithms are compatible with the problem type. Defaults to <code>Float64</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/9a0bb8d22fdeeeeca84cedd93357578f3dac2264/src/default.jl#L456-L467">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.RobustMultiNewton" href="#NonlinearSolve.RobustMultiNewton"><code>NonlinearSolve.RobustMultiNewton</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">RobustMultiNewton(::Type{T} = Float64; concrete_jac = nothing, linsolve = nothing,
    precs = DEFAULT_PRECS, autodiff = nothing)</code></pre><p>A polyalgorithm focused on robustness. It uses a mixture of Newton methods with different globalizing techniques (trust region updates, line searches, etc.) in order to find a method that is able to adequately solve the minimization problem.</p><p>Basically, if this algorithm fails, then &quot;most&quot; good ways of solving your problem fail and you may need to think about reformulating the model (either there is an issue with the model, or more precision / more stable linear solver choice is required).</p><p><strong>Arguments</strong></p><ul><li><code>T</code>: The eltype of the initial guess. It is only used to check if some of the algorithms are compatible with the problem type. Defaults to <code>Float64</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/9a0bb8d22fdeeeeca84cedd93357578f3dac2264/src/default.jl#L339-L355">source</a></section></article><h2 id="Advanced-Solvers"><a class="docs-heading-anchor" href="#Advanced-Solvers">Advanced Solvers</a><a id="Advanced-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Solvers" title="Permalink"></a></h2><p>All of the previously mentioned solvers are wrappers around the following solvers. These are meant for advanced users and allow building custom solvers.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.ApproximateJacobianSolveAlgorithm" href="#NonlinearSolve.ApproximateJacobianSolveAlgorithm"><code>NonlinearSolve.ApproximateJacobianSolveAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ApproximateJacobianSolveAlgorithm{concrete_jac, name}(; linesearch = missing,
    trustregion = missing, descent, update_rule, reinit_rule, initialization,
    max_resets::Int = typemax(Int), max_shrink_times::Int = typemax(Int))
ApproximateJacobianSolveAlgorithm(; concrete_jac = nothing,
    name::Symbol = :unknown, kwargs...)</code></pre><p>Nonlinear Solve Algorithms using an Iterative Approximation of the Jacobian. Most common examples include <a href="#NonlinearSolve.Broyden"><code>Broyden</code></a>&#39;s Method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>trustregion</code>: Globalization using a Trust Region Method. This needs to follow the <a href="../../devdocs/internal_interfaces/#NonlinearSolve.AbstractTrustRegionMethod"><code>NonlinearSolve.AbstractTrustRegionMethod</code></a> interface.</li><li><code>descent</code>: The descent method to use to compute the step. This needs to follow the <a href="../../devdocs/internal_interfaces/#NonlinearSolve.AbstractDescentAlgorithm"><code>NonlinearSolve.AbstractDescentAlgorithm</code></a> interface.</li><li><code>max_shrink_times</code>: The maximum number of times the trust region radius can be shrunk before the algorithm terminates.</li><li><code>update_rule</code>: The update rule to use to update the Jacobian. This needs to follow the <a href="../../devdocs/internal_interfaces/#NonlinearSolve.AbstractApproximateJacobianUpdateRule"><code>NonlinearSolve.AbstractApproximateJacobianUpdateRule</code></a> interface.</li><li><code>reinit_rule</code>: The reinitialization rule to use to reinitialize the Jacobian. This needs to follow the <a href="../../devdocs/internal_interfaces/#NonlinearSolve.AbstractResetCondition"><code>NonlinearSolve.AbstractResetCondition</code></a> interface.</li><li><code>initialization</code>: The initialization method to use to initialize the Jacobian. This needs to follow the <a href="../../devdocs/internal_interfaces/#NonlinearSolve.AbstractJacobianInitialization"><code>NonlinearSolve.AbstractJacobianInitialization</code></a> interface.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/9a0bb8d22fdeeeeca84cedd93357578f3dac2264/src/core/approximate_jacobian.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.GeneralizedFirstOrderAlgorithm" href="#NonlinearSolve.GeneralizedFirstOrderAlgorithm"><code>NonlinearSolve.GeneralizedFirstOrderAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeneralizedFirstOrderAlgorithm{concrete_jac, name}(; descent, linesearch = missing,
    trustregion = missing, jacobian_ad = nothing, forward_ad = nothing,
    reverse_ad = nothing, max_shrink_times::Int = typemax(Int))
GeneralizedFirstOrderAlgorithm(; concrete_jac = nothing, name::Symbol = :unknown,
    kwargs...)</code></pre><p>This is a Generalization of First-Order (uses Jacobian) Nonlinear Solve Algorithms. The most common example of this is Newton-Raphson Method.</p><p>First Order here refers to the order of differentiation, and should not be confused with the order of convergence.</p><p><code>trustregion</code> and <code>linesearch</code> cannot be specified together.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>trustregion</code>: Globalization using a Trust Region Method. This needs to follow the <a href="../../devdocs/internal_interfaces/#NonlinearSolve.AbstractTrustRegionMethod"><code>NonlinearSolve.AbstractTrustRegionMethod</code></a> interface.</li><li><code>descent</code>: The descent method to use to compute the step. This needs to follow the <a href="../../devdocs/internal_interfaces/#NonlinearSolve.AbstractDescentAlgorithm"><code>NonlinearSolve.AbstractDescentAlgorithm</code></a> interface.</li><li><code>max_shrink_times</code>: The maximum number of times the trust region radius can be shrunk before the algorithm terminates.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/9a0bb8d22fdeeeeca84cedd93357578f3dac2264/src/core/generalized_first_order.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.GeneralizedDFSane" href="#NonlinearSolve.GeneralizedDFSane"><code>NonlinearSolve.GeneralizedDFSane</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeneralizedDFSane{name}(linesearch, σ_min, σ_max, σ_1)</code></pre><p>A generalized version of the DF-SANE algorithm. This algorithm is a Jacobian-Free Spectral Method.</p><p><strong>Arguments</strong></p><ul><li><code>linesearch</code>: Globalization using a Line Search Method. This needs to follow the <a href="../../devdocs/internal_interfaces/#NonlinearSolve.AbstractNonlinearSolveLineSearchAlgorithm"><code>NonlinearSolve.AbstractNonlinearSolveLineSearchAlgorithm</code></a> interface. This is not optional currently, but that restriction might be lifted in the future.</li><li><code>σ_min</code>: The minimum spectral parameter allowed. This is used to ensure that the spectral parameter is not too small.</li><li><code>σ_max</code>: The maximum spectral parameter allowed. This is used to ensure that the spectral parameter is not too large.</li><li><code>σ_1</code>: The initial spectral parameter. If this is not provided, then the algorithm initializes it as <code>σ_1 = &lt;u, u&gt; / &lt;u, f(u)&gt;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/9a0bb8d22fdeeeeca84cedd93357578f3dac2264/src/core/spectral_methods.jl#L4-L21">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../solvers/fixed_point_solvers/">« Fixed Point Solvers</a><a class="docs-footer-nextpage" href="../simplenonlinearsolve/">SimpleNonlinearSolve.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Wednesday 17 April 2024 14:42">Wednesday 17 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
