<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Code Optimization for Small Nonlinear Systems in Julia · NonlinearSolve.jl</title><meta name="title" content="Code Optimization for Small Nonlinear Systems in Julia · NonlinearSolve.jl"/><meta property="og:title" content="Code Optimization for Small Nonlinear Systems in Julia · NonlinearSolve.jl"/><meta property="twitter:title" content="Code Optimization for Small Nonlinear Systems in Julia · NonlinearSolve.jl"/><meta name="description" content="Documentation for NonlinearSolve.jl."/><meta property="og:description" content="Documentation for NonlinearSolve.jl."/><meta property="twitter:description" content="Documentation for NonlinearSolve.jl."/><meta property="og:url" content="https://docs.sciml.ai/NonlinearSolve/stable/tutorials/code_optimization/"/><meta property="twitter:url" content="https://docs.sciml.ai/NonlinearSolve/stable/tutorials/code_optimization/"/><link rel="canonical" href="https://docs.sciml.ai/NonlinearSolve/stable/tutorials/code_optimization/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="NonlinearSolve.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NonlinearSolve.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers</a></li><li><a class="tocitem" href="../getting_started/">Getting Started with Nonlinear Rootfinding in Julia</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Code Optimization for Small Nonlinear Systems in Julia</a><ul class="internal"><li><a class="tocitem" href="#General-Code-Optimization-in-Julia"><span>General Code Optimization in Julia</span></a></li><li><a class="tocitem" href="#Optimizing-Nonlinear-Solver-Code-for-Small-Systems"><span>Optimizing Nonlinear Solver Code for Small Systems</span></a></li><li><a class="tocitem" href="#Further-Optimizations-for-Small-Nonlinear-Solves-with-Static-Arrays-and-SimpleNonlinearSolve"><span>Further Optimizations for Small Nonlinear Solves with Static Arrays and SimpleNonlinearSolve</span></a></li></ul></li><li><a class="tocitem" href="../large_systems/">Efficiently Solving Large Sparse Ill-Conditioned Nonlinear Systems in Julia</a></li><li><a class="tocitem" href="../modelingtoolkit/">Symbolic Nonlinear System Definition and Acceleration via ModelingToolkit</a></li><li><a class="tocitem" href="../small_compile/">Faster Startup and and Static Compilation</a></li><li><a class="tocitem" href="../iterator_interface/">Nonlinear Solver Iterator Interface</a></li><li><a class="tocitem" href="../optimizing_parameterized_ode/">Optimizing a Parameterized ODE</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/NonlinearProblem/">Nonlinear Problems</a></li><li><a class="tocitem" href="../../basics/NonlinearFunctions/">NonlinearFunctions and Jacobian Types</a></li><li><a class="tocitem" href="../../basics/solve/">Common Solver Options (Solve Keyword Arguments)</a></li><li><a class="tocitem" href="../../basics/NonlinearSolution/">Nonlinear Solutions</a></li><li><a class="tocitem" href="../../basics/TerminationCondition/">Termination Conditions</a></li><li><a class="tocitem" href="../../basics/Logging/">Logging the Solve Process</a></li><li><a class="tocitem" href="../../basics/SparsityDetection/">(Semi-)Automatic Sparsity Detection</a></li><li><a class="tocitem" href="../../basics/FAQ/">Frequently Asked Questions</a></li></ul></li><li><span class="tocitem">Solver Summaries and Recommendations</span><ul><li><a class="tocitem" href="../../solvers/NonlinearSystemSolvers/">Nonlinear System Solvers</a></li><li><a class="tocitem" href="../../solvers/BracketingSolvers/">Interval Rootfinding Methods (Bracketing Solvers)</a></li><li><a class="tocitem" href="../../solvers/SteadyStateSolvers/">Steady State Solvers</a></li><li><a class="tocitem" href="../../solvers/NonlinearLeastSquaresSolvers/">Nonlinear Least Squares Solvers</a></li><li><a class="tocitem" href="../../solvers/FixedPointSolvers/">Fixed Point Solvers</a></li><li><a class="tocitem" href="../../solvers/LineSearch/">Line Search</a></li></ul></li><li><span class="tocitem">Detailed Solver APIs</span><ul><li><a class="tocitem" href="../../api/nonlinearsolve/">NonlinearSolve.jl Native Solvers</a></li><li><a class="tocitem" href="../../api/simplenonlinearsolve/">SimpleNonlinearSolve.jl</a></li><li><a class="tocitem" href="../../api/minpack/">MINPACK.jl</a></li><li><a class="tocitem" href="../../api/nlsolve/">NLsolve.jl</a></li><li><a class="tocitem" href="../../api/sundials/">Sundials.jl</a></li><li><a class="tocitem" href="../../api/steadystatediffeq/">SteadyStateDiffEq.jl</a></li><li><a class="tocitem" href="../../api/leastsquaresoptim/">LeastSquaresOptim.jl</a></li><li><a class="tocitem" href="../../api/fastlevenbergmarquardt/">FastLevenbergMarquardt.jl</a></li><li><a class="tocitem" href="../../api/speedmapping/">SpeedMapping.jl</a></li><li><a class="tocitem" href="../../api/fixedpointacceleration/">FixedPointAcceleration.jl</a></li><li><a class="tocitem" href="../../api/siamfanlequations/">SIAMFANLEquations.jl</a></li></ul></li><li><a class="tocitem" href="../../release_notes/">Release Notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Code Optimization for Small Nonlinear Systems in Julia</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Code Optimization for Small Nonlinear Systems in Julia</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/NonlinearSolve.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/NonlinearSolve.jl/blob/master/docs/src/tutorials/code_optimization.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="code_optimization"><a class="docs-heading-anchor" href="#code_optimization">Code Optimization for Small Nonlinear Systems in Julia</a><a id="code_optimization-1"></a><a class="docs-heading-anchor-permalink" href="#code_optimization" title="Permalink"></a></h1><h2 id="General-Code-Optimization-in-Julia"><a class="docs-heading-anchor" href="#General-Code-Optimization-in-Julia">General Code Optimization in Julia</a><a id="General-Code-Optimization-in-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#General-Code-Optimization-in-Julia" title="Permalink"></a></h2><p>Before starting this tutorial, we recommend the reader to check out one of the many tutorials for optimization Julia code. The following is an incomplete list:</p><ul><li><a href="https://docs.julialang.org/en/v1/manual/performance-tips/">The Julia Performance Tips</a></li><li><a href="https://mitmath.github.io/18337/lecture2/optimizing">MIT 18.337 Course Notes on Optimizing Serial Code</a></li><li><a href="https://viralinstruction.com/posts/hardware/">What scientists must know about hardware to write fast code</a></li></ul><p>User-side optimizations are important because, for sufficiently difficult problems, most time will be spent inside your <code>f</code> function, the function you are trying to solve. “Efficient solvers&quot; are those that reduce the required number of <code>f</code> calls to hit the error tolerance. The main ideas for optimizing your nonlinear solver code, or any Julia function, are the following:</p><ul><li>Make it non-allocating</li><li>Use StaticArrays for small arrays</li><li>Use broadcast fusion</li><li>Make it type-stable</li><li>Reduce redundant calculations</li><li>Make use of BLAS calls</li><li>Optimize algorithm choice</li></ul><p>We&#39;ll discuss these strategies in the context of nonlinear solvers. Let&#39;s start with small systems.</p><h2 id="Optimizing-Nonlinear-Solver-Code-for-Small-Systems"><a class="docs-heading-anchor" href="#Optimizing-Nonlinear-Solver-Code-for-Small-Systems">Optimizing Nonlinear Solver Code for Small Systems</a><a id="Optimizing-Nonlinear-Solver-Code-for-Small-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizing-Nonlinear-Solver-Code-for-Small-Systems" title="Permalink"></a></h2><p>Take for example a prototypical small nonlinear solver code in its out-of-place form:</p><pre><code class="language-julia hljs">using NonlinearSolve

function f(u, p)
    u .* u .- p
end
u0 = [1.0, 1.0]
p = 2.0
prob = NonlinearProblem(f, u0, p)
sol = solve(prob, NewtonRaphson())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
u: 2-element Vector{Float64}:
 1.4142135623730951
 1.4142135623730951</code></pre><p>We can use BenchmarkTools.jl to get more precise timings:</p><pre><code class="language-julia hljs">using BenchmarkTools

@benchmark solve(prob, NewtonRaphson())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 6 evaluations.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">5.664 μs</span></span> … <span class="sgr35">665.573 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 97.32%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">5.939 μs               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">6.393 μs</span></span> ± <span class="sgr32"> 12.436 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>3.83% ±  1.95%

   ▄▆▇██<span class="sgr34">▇</span>▇▅▅▄▄▃▃▃▃▃<span class="sgr32">▃</span>▃▃▂▂▂▁▁▁▁▁   ▁ ▁       ▁ ▁                ▂
  ██████<span class="sgr34">█</span>██████████<span class="sgr32">█</span>████████████████████████▇█▇███▇▇▆▇▆▇▇▇▆▅▆ █
  5.66 μs<span class="sgr90">      Histogram: <span class="sgr1">log(</span>frequency<span class="sgr1">)</span> by time</span>      8.24 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">5.02 KiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">56</span>.</code></pre><p>Note that this way of writing the function is a shorthand for:</p><pre><code class="language-julia hljs">function f(u, p)
    [u[1] * u[1] - p, u[2] * u[2] - p]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">f (generic function with 1 method)</code></pre><p>where the function <code>f</code> returns an array. This is a common pattern from things like MATLAB&#39;s <code>fzero</code> or SciPy&#39;s <code>scipy.optimize.fsolve</code>. However, by design it&#39;s very slow. In the benchmark you can see that there are many allocations. These allocations cause the memory allocator to take more time than the actual numerics itself, which is one of the reasons why codes from MATLAB and Python end up slow.</p><p>In order to avoid this issue, we can use a non-allocating &quot;in-place&quot; approach. Written out by hand, this looks like:</p><pre><code class="language-julia hljs">function f(du, u, p)
    du[1] = u[1] * u[1] - p
    du[2] = u[2] * u[2] - p
    nothing
end

prob = NonlinearProblem(f, u0, p)
@benchmark sol = solve(prob, NewtonRaphson())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 6 evaluations.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">5.470 μs</span></span> … <span class="sgr35">776.366 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 97.48%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">5.831 μs               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">6.304 μs</span></span> ± <span class="sgr32"> 12.918 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>3.47% ±  1.68%

     ▃██▅<span class="sgr34">▂</span>         <span class="sgr32"> </span>                                           
  ▁▂▆████<span class="sgr34">█</span>█▆▅▄▄▄▃▃▃<span class="sgr32">▃</span>▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂
  5.47 μs<span class="sgr90">         Histogram: frequency by time</span>        8.34 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">4.14 KiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">46</span>.</code></pre><p>Notice how much faster this already runs! We can make this code even simpler by using the <code>.=</code> in-place broadcasting.</p><pre><code class="language-julia hljs">function f(du, u, p)
    du .= u .* u .- p
end

@benchmark sol = solve(prob, NewtonRaphson())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 6 evaluations.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">5.530 μs</span></span> … <span class="sgr35">758.022 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 97.40%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">5.961 μs               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">6.377 μs</span></span> ± <span class="sgr32"> 12.846 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>3.44% ±  1.69%

       ▁▅▇█▇<span class="sgr34">▅</span>▂         <span class="sgr32"> </span>                                       
  ▂▁▂▃▅█████<span class="sgr34">█</span>██▆▅▅▄▅▄▄▄<span class="sgr32">▄</span>▄▄▄▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▂▂▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ ▃
  5.53 μs<span class="sgr90">         Histogram: frequency by time</span>        7.97 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">4.14 KiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">46</span>.</code></pre><h2 id="Further-Optimizations-for-Small-Nonlinear-Solves-with-Static-Arrays-and-SimpleNonlinearSolve"><a class="docs-heading-anchor" href="#Further-Optimizations-for-Small-Nonlinear-Solves-with-Static-Arrays-and-SimpleNonlinearSolve">Further Optimizations for Small Nonlinear Solves with Static Arrays and SimpleNonlinearSolve</a><a id="Further-Optimizations-for-Small-Nonlinear-Solves-with-Static-Arrays-and-SimpleNonlinearSolve-1"></a><a class="docs-heading-anchor-permalink" href="#Further-Optimizations-for-Small-Nonlinear-Solves-with-Static-Arrays-and-SimpleNonlinearSolve" title="Permalink"></a></h2><p>Allocations are only expensive if they are “heap allocations”. For a more in-depth definition of heap allocations, <a href="http://net-informations.com/faq/net/stack-heap.htm">there are many sources online</a>. But a good working definition is that heap allocations are variable-sized slabs of memory which have to be pointed to, and this pointer indirection costs time. Additionally, the heap has to be managed, and the garbage controllers has to actively keep track of what&#39;s on the heap.</p><p>However, there&#39;s an alternative to heap allocations, known as stack allocations. The stack is statically-sized (known at compile time) and thus its accesses are quick. Additionally, the exact block of memory is known in advance by the compiler, and thus re-using the memory is cheap. This means that allocating on the stack has essentially no cost!</p><p>Arrays have to be heap allocated because their size (and thus the amount of memory they take up) is determined at runtime. But there are structures in Julia which are stack-allocated. <code>struct</code>s for example are stack-allocated “value-type”s. <code>Tuple</code>s are a stack-allocated collection. The most useful data structure for NonlinearSolve though is the <code>StaticArray</code> from the package <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a>. These arrays have their length determined at compile-time. They are created using macros attached to normal array expressions, for example:</p><pre><code class="language-julia hljs">using StaticArrays
A = SA[2.0, 3.0, 5.0]
typeof(A) # SVector{3, Float64} (alias for SArray{Tuple{3}, Float64, 1, 3})</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SVector{3, Float64}<span class="sgr90"> (alias for StaticArraysCore.SArray{Tuple{3}, Float64, 1, 3})</span></code></pre><p>Notice that the <code>3</code> after <code>SVector</code> gives the size of the <code>SVector</code>. It cannot be changed. Additionally, <code>SVector</code>s are immutable, so we have to create a new <code>SVector</code> to change values. But remember, we don&#39;t have to worry about allocations because this data structure is stack-allocated. <code>SArray</code>s have numerous extra optimizations as well: they have fast matrix multiplication, fast QR factorizations, etc. which directly make use of the information about the size of the array. Thus, when possible, they should be used.</p><p>Unfortunately, static arrays can only be used for sufficiently small arrays. After a certain size, they are forced to heap allocate after some instructions and their compile time balloons. Thus, static arrays shouldn&#39;t be used if your system has more than ~20 variables. Additionally, only the native Julia algorithms can fully utilize static arrays.</p><p>Let&#39;s ***optimize our nonlinear solve using static arrays***. Note that in this case, we want to use the out-of-place allocating form, but this time we want to output a static array. Doing it with broadcasting looks like:</p><pre><code class="language-julia hljs">function f_SA(u, p)
    u .* u .- p
end
u0 = SA[1.0, 1.0]
p = 2.0
prob = NonlinearProblem(f_SA, u0, p)
@benchmark solve(prob, NewtonRaphson())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 10 evaluations.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">1.506 μs</span></span> … <span class="sgr35">342.144 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 98.19%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">1.674 μs               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">1.896 μs</span></span> ± <span class="sgr32">  4.790 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>3.53% ±  1.39%

       ▄██▆<span class="sgr34">▁</span>            <span class="sgr32"> </span>                                      
  ▁▁▂▂▅████<span class="sgr34">█</span>▇▅▃▃▂▁▁▁▂▂▂▁<span class="sgr32">▁</span>▁▁▁▃▄▄▃▂▁▁▁▂▄▅▄▃▂▂▁▁▂▂▃▃▂▂▁▁▁▁▁▂▁▁▁▁ ▂
  1.51 μs<span class="sgr90">         Histogram: frequency by time</span>        2.55 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">1.62 KiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">8</span>.</code></pre><p>Note that only change here is that <code>u0</code> is made into a StaticArray! If we needed to write <code>f</code> out for a more complex nonlinear case, then we&#39;d simply do the following:</p><pre><code class="language-julia hljs">function f_SA(u, p)
    SA[u[1] * u[1] - p, u[2] * u[2] - p]
end

@benchmark solve(prob, NewtonRaphson())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 10 evaluations.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">1.294 μs</span></span> … <span class="sgr35">334.984 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 98.51%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">1.435 μs               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">1.660 μs</span></span> ± <span class="sgr32">  4.653 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>3.92% ±  1.39%

     ▂▆█▆▃<span class="sgr34"> </span>           <span class="sgr32"> </span>                                        
  ▁▂▅█████<span class="sgr34">█</span>▆▄▃▂▂▂▁▁▁▂▂<span class="sgr32">▂</span>▁▁▁▁▁▃▅▅▃▂▁▁▁▂▄▆▅▃▂▂▁▁▂▂▃▃▂▁▁▁▁▁▁▁▁▁▁▁ ▂
  1.29 μs<span class="sgr90">         Histogram: frequency by time</span>        2.35 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">1.62 KiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">8</span>.</code></pre><p>However, notice that this did not give us a speedup but rather a slowdown. This is because many of the methods in NonlinearSolve.jl are designed to scale to larger problems, and thus aggressively do things like caching which is good for large problems but not good for these smaller problems and static arrays. In order to see the full benefit, we need to move to one of the methods from SimpleNonlinearSolve.jl which are designed for these small-scale static examples. Let&#39;s now use <code>SimpleNewtonRaphson</code>:</p><pre><code class="language-julia hljs">@benchmark solve(prob, SimpleNewtonRaphson())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 119 evaluations.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">751.067 ns</span></span> … <span class="sgr35"> 36.287 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 96.88%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">779.605 ns               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">782.707 ns</span></span> ± <span class="sgr32">356.034 ns</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.45% ±  0.97%

     ▄          <span class="sgr34">█</span>▁<span class="sgr32"> </span>                                              
  ▂▅███▃▂▂▂▂▂▁▁▄<span class="sgr34">█</span>█<span class="sgr32">▂</span>▂▁▂▇█▃▂▁▂▂▃▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂
  751 ns<span class="sgr90">           Histogram: frequency by time</span>          872 ns <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">80 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">1</span>.</code></pre><p>And there we go, around <code>40ns</code> from our starting point of almost <code>4μs</code>!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started/">« Getting Started with Nonlinear Rootfinding in Julia</a><a class="docs-footer-nextpage" href="../large_systems/">Efficiently Solving Large Sparse Ill-Conditioned Nonlinear Systems in Julia »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 28 December 2023 12:35">Thursday 28 December 2023</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
