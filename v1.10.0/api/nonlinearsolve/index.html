<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>NonlinearSolve.jl Native Solvers · NonlinearSolve.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/NonlinearSolve/stable/api/nonlinearsolve/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="NonlinearSolve.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NonlinearSolve.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/nonlinear/">Solving Nonlinear Systems</a></li><li><a class="tocitem" href="../../tutorials/iterator_interface/">Nonlinear Solver Iterator Interface</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/NonlinearProblem/">Nonlinear Problems</a></li><li><a class="tocitem" href="../../basics/NonlinearFunctions/">NonlinearFunctions and Jacobian Types</a></li><li><a class="tocitem" href="../../basics/solve/">Common Solver Options (Solve Keyword Arguments)</a></li><li><a class="tocitem" href="../../basics/NonlinearSolution/">Nonlinear Solutions</a></li><li><a class="tocitem" href="../../basics/TerminationCondition/">Termination Conditions</a></li><li><a class="tocitem" href="../../basics/FAQ/">Frequently Asked Questions</a></li></ul></li><li><span class="tocitem">Solver Summaries and Recommendations</span><ul><li><a class="tocitem" href="../../solvers/NonlinearSystemSolvers/">Nonlinear System Solvers</a></li><li><a class="tocitem" href="../../solvers/BracketingSolvers/">Interval Rootfinding Methods (Bracketing Solvers)</a></li><li><a class="tocitem" href="../../solvers/SteadyStateSolvers/">Steady State Solvers</a></li></ul></li><li><span class="tocitem">Detailed Solver APIs</span><ul><li class="is-active"><a class="tocitem" href>NonlinearSolve.jl Native Solvers</a><ul class="internal"><li><a class="tocitem" href="#Solver-API"><span>Solver API</span></a></li><li><a class="tocitem" href="#Radius-Update-Schemes-for-Trust-Region-(RadiusUpdateSchemes)"><span>Radius Update Schemes for Trust Region (RadiusUpdateSchemes)</span></a></li></ul></li><li><a class="tocitem" href="../simplenonlinearsolve/">SimpleNonlinearSolve.jl</a></li><li><a class="tocitem" href="../minpack/">MINPACK.jl</a></li><li><a class="tocitem" href="../nlsolve/">NLsolve.jl</a></li><li><a class="tocitem" href="../sundials/">Sundials.jl</a></li><li><a class="tocitem" href="../steadystatediffeq/">SteadyStateDiffEq.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Detailed Solver APIs</a></li><li class="is-active"><a href>NonlinearSolve.jl Native Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>NonlinearSolve.jl Native Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/NonlinearSolve.jl/blob/master/docs/src/api/nonlinearsolve.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="NonlinearSolve.jl-Native-Solvers"><a class="docs-heading-anchor" href="#NonlinearSolve.jl-Native-Solvers">NonlinearSolve.jl Native Solvers</a><a id="NonlinearSolve.jl-Native-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#NonlinearSolve.jl-Native-Solvers" title="Permalink"></a></h1><p>These are the native solvers of NonlinearSolve.jl.</p><h2 id="Solver-API"><a class="docs-heading-anchor" href="#Solver-API">Solver API</a><a id="Solver-API-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NonlinearSolve.NewtonRaphson" href="#NonlinearSolve.NewtonRaphson"><code>NonlinearSolve.NewtonRaphson</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NewtonRaphson(; chunk_size = Val{0}(), autodiff = Val{true}(),
              standardtag = Val{true}(), concrete_jac = nothing,
              diff_type = Val{:forward}, linsolve = nothing, precs = DEFAULT_PRECS)</code></pre><p>An advanced NewtonRaphson implementation with support for efficient handling of sparse matrices via colored automatic differentiation and preconditioned linear solvers. Designed for large-scale and numerically-difficult nonlinear systems.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: the chunk size used by the internal ForwardDiff.jl automatic differentiation system. This allows for multiple derivative columns to be computed simultaneously, improving performance. Defaults to <code>0</code>, which is equivalent to using ForwardDiff.jl&#39;s default chunk size mechanism. For more details, see the documentation for <a href="https://juliadiff.org/ForwardDiff.jl/stable/">ForwardDiff.jl</a>.</li><li><code>autodiff</code>: whether to use forward-mode automatic differentiation for the Jacobian. Note that this argument is ignored if an analytical Jacobian is passed, as that will be used instead. Defaults to <code>Val{true}</code>, which means ForwardDiff.jl via SparseDiffTools.jl is used by default. If <code>Val{false}</code>, then FiniteDiff.jl is used for finite differencing.</li><li><code>standardtag</code>: whether to use a standardized tag definition for the purposes of automatic differentiation. Defaults to true, which thus uses the <code>NonlinearSolveTag</code>. If <code>Val{false}</code>, then ForwardDiff&#39;s default function naming tag is used, which results in larger stack traces.</li><li><code>concrete_jac</code>: whether to build a concrete Jacobian. If a Krylov-subspace method is used, then the Jacobian will not be constructed and instead direct Jacobian-vector products <code>J*v</code> are computed using forward-mode automatic differentiation or finite differencing tricks (without ever constructing the Jacobian). However, if the Jacobian is still needed, for example for a preconditioner, <code>concrete_jac = true</code> can be passed in order to force the construction of the Jacobian.</li><li><code>diff_type</code>: the type of finite differencing used if <code>autodiff = false</code>. Defaults to <code>Val{:forward}</code> for forward finite differences. For more details on the choices, see the <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a> documentation.</li><li><code>linsolve</code>: the <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> used for the linear solves within the Newton method. Defaults to <code>nothing</code>, which means it uses the LinearSolve.jl default algorithm choice. For more information on available algorithm choices, see the <a href="https://docs.sciml.ai/LinearSolve/stable/">LinearSolve.jl documentation</a>.</li><li><code>precs</code>: the choice of preconditioners for the linear solver. Defaults to using no preconditioners. For more information on specifying preconditioners for LinearSolve algorithms, consult the <a href="https://docs.sciml.ai/LinearSolve/stable/">LinearSolve.jl documentation</a>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Currently, the linear solver and chunk size choice only applies to in-place defined <code>NonlinearProblem</code>s. That is expected to change in the future.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/aedd385e0f527d05972ad3573ae95af1208eacd3/src/raphson.jl#L1-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearSolve.TrustRegion" href="#NonlinearSolve.TrustRegion"><code>NonlinearSolve.TrustRegion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TrustRegion(; chunk_size = Val{0}(), autodiff = Val{true}(),
            standardtag = Val{true}(), concrete_jac = nothing,
            diff_type = Val{:forward}, linsolve = nothing, precs = DEFAULT_PRECS,
            radius_update_scheme = RadiusUpdateSchemes.Simple,
            max_trust_radius::Real = 0 // 1,
            initial_trust_radius::Real = 0 // 1,
            step_threshold::Real = 1 // 10,
            shrink_threshold::Real = 1 // 4,
            expand_threshold::Real = 3 // 4,
            shrink_factor::Real = 1 // 4,
            expand_factor::Real = 2 // 1,
            max_shrink_times::Int = 32)</code></pre><p>An advanced TrustRegion implementation with support for efficient handling of sparse matrices via colored automatic differentiation and preconditioned linear solvers. Designed for large-scale and numerically-difficult nonlinear systems.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: the chunk size used by the internal ForwardDiff.jl automatic differentiation system. This allows for multiple derivative columns to be computed simultaneously, improving performance. Defaults to <code>0</code>, which is equivalent to using ForwardDiff.jl&#39;s default chunk size mechanism. For more details, see the documentation for <a href="https://juliadiff.org/ForwardDiff.jl/stable/">ForwardDiff.jl</a>.</li><li><code>autodiff</code>: whether to use forward-mode automatic differentiation for the Jacobian. Note that this argument is ignored if an analytical Jacobian is passed, as that will be used instead. Defaults to <code>Val{true}</code>, which means ForwardDiff.jl via SparseDiffTools.jl is used by default. If <code>Val{false}</code>, then FiniteDiff.jl is used for finite differencing.</li><li><code>standardtag</code>: whether to use a standardized tag definition for the purposes of automatic differentiation. Defaults to true, which thus uses the <code>NonlinearSolveTag</code>. If <code>Val{false}</code>, then ForwardDiff&#39;s default function naming tag is used, which results in larger stack traces.</li><li><code>concrete_jac</code>: whether to build a concrete Jacobian. If a Krylov-subspace method is used, then the Jacobian will not be constructed and instead direct Jacobian-vector products <code>J*v</code> are computed using forward-mode automatic differentiation or finite differencing tricks (without ever constructing the Jacobian). However, if the Jacobian is still needed, for example for a preconditioner, <code>concrete_jac = true</code> can be passed in order to force the construction of the Jacobian.</li><li><code>diff_type</code>: the type of finite differencing used if <code>autodiff = false</code>. Defaults to <code>Val{:forward}</code> for forward finite differences. For more details on the choices, see the <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a> documentation.</li><li><code>linsolve</code>: the <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> used for the linear solves within the Newton method. Defaults to <code>nothing</code>, which means it uses the LinearSolve.jl default algorithm choice. For more information on available algorithm choices, see the <a href="https://docs.sciml.ai/LinearSolve/stable/">LinearSolve.jl documentation</a>.</li><li><code>precs</code>: the choice of preconditioners for the linear solver. Defaults to using no preconditioners. For more information on specifying preconditioners for LinearSolve algorithms, consult the <a href="https://docs.sciml.ai/LinearSolve/stable/">LinearSolve.jl documentation</a>.</li><li><code>radius_update_scheme</code>: the choice of radius update scheme to be used. Defaults to <code>RadiusUpdateSchemes.Simple</code> which follows the conventional approach. Other available schemes are <code>RadiusUpdateSchemes.Hei</code>,  <code>RadiusUpdateSchemes.Yuan</code>, <code>RadiusUpdateSchemes.Bastin</code>, <code>RadiusUpdateSchemes.Fan</code>. These schemes have the trust region radius converging to zero that is seen to improve convergence. For more details, see the <a href="https://link.springer.com/article/10.1007/s10107-015-0893-2#Sec4">Yuan, Yx</a>.</li><li><code>max_trust_radius</code>: the maximal trust region radius. Defaults to <code>max(norm(fu), maximum(u) - minimum(u))</code>.</li><li><code>initial_trust_radius</code>: the initial trust region radius. Defaults to <code>max_trust_radius / 11</code>.</li><li><code>step_threshold</code>: the threshold for taking a step. In every iteration, the threshold is compared with a value <code>r</code>, which is the actual reduction in the objective function divided by the predicted reduction. If <code>step_threshold &gt; r</code> the model is not a good approximation, and the step is rejected. Defaults to <code>0.1</code>. For more details, see <a href="https://link.springer.com/article/10.1007/s40096-020-00339-4">Rahpeymaii, F.</a></li><li><code>shrink_threshold</code>: the threshold for shrinking the trust region radius. In every iteration, the threshold is compared with a value <code>r</code> which is the actual reduction in the objective function divided by the predicted reduction. If <code>shrink_threshold &gt; r</code> the trust region radius is shrunk by <code>shrink_factor</code>. Defaults to <code>0.25</code>. For more details, see <a href="https://link.springer.com/article/10.1007/s40096-020-00339-4">Rahpeymaii, F.</a></li><li><code>expand_threshold</code>: the threshold for expanding the trust region radius. If a step is taken, i.e <code>step_threshold &lt; r</code> (with <code>r</code> defined in <code>shrink_threshold</code>), a check is also made to see if <code>expand_threshold &lt; r</code>. If that is true, the trust region radius is expanded by <code>expand_factor</code>. Defaults to <code>0.75</code>.</li><li><code>shrink_factor</code>: the factor to shrink the trust region radius with if <code>shrink_threshold &gt; r</code> (with <code>r</code> defined in <code>shrink_threshold</code>). Defaults to <code>0.25</code>.</li><li><code>expand_factor</code>: the factor to expand the trust region radius with if <code>expand_threshold &lt; r</code> (with <code>r</code> defined in <code>shrink_threshold</code>). Defaults to <code>2.0</code>.</li><li><code>max_shrink_times</code>: the maximum number of times to shrink the trust region radius in a row, <code>max_shrink_times</code> is exceeded, the algorithm returns. Defaults to <code>32</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Currently, the linear solver and chunk size choice only applies to in-place defined <code>NonlinearProblem</code>s. That is expected to change in the future.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/aedd385e0f527d05972ad3573ae95af1208eacd3/src/trustRegion.jl#L69-L156">source</a></section></article><h2 id="Radius-Update-Schemes-for-Trust-Region-(RadiusUpdateSchemes)"><a class="docs-heading-anchor" href="#Radius-Update-Schemes-for-Trust-Region-(RadiusUpdateSchemes)">Radius Update Schemes for Trust Region (RadiusUpdateSchemes)</a><a id="Radius-Update-Schemes-for-Trust-Region-(RadiusUpdateSchemes)-1"></a><a class="docs-heading-anchor-permalink" href="#Radius-Update-Schemes-for-Trust-Region-(RadiusUpdateSchemes)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NonlinearSolve.RadiusUpdateSchemes" href="#NonlinearSolve.RadiusUpdateSchemes"><code>NonlinearSolve.RadiusUpdateSchemes</code></a> — <span class="docstring-category">Module</span></header><section><div><p><code>RadiusUpdateSchemes</code></p><p><code>RadiusUpdateSchemes</code> is the standard enum interface for different types of radius update schemes implemented in the Trust Region method. These schemes specify how the radius of the so-called trust region is updated after each iteration of the algorithm. The specific role and caveats associated with each scheme are provided below.</p><p><strong>Using <code>RadiusUpdateSchemes</code></strong></p><p><code>RadiusUpdateSchemes</code> uses the standard EnumX interface (https://github.com/fredrikekre/EnumX.jl),  and hence inherits all properties of being an EnumX, including the type of each constituent enum states as <code>RadiusUpdateSchemes.T</code>. Simply put the desired scheme as follows: <code>TrustRegion(radius_update_scheme = your desired update scheme)</code>. For example, <code>sol = solve(prob, alg=TrustRegion(radius_update_scheme = RadiusUpdateSchemes.Hei))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/aedd385e0f527d05972ad3573ae95af1208eacd3/src/trustRegion.jl#L1-L16">source</a></section></article><h3 id="Available-Radius-Update-Schemes"><a class="docs-heading-anchor" href="#Available-Radius-Update-Schemes">Available Radius Update Schemes</a><a id="Available-Radius-Update-Schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Available-Radius-Update-Schemes" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="NonlinearSolve.RadiusUpdateSchemes.Simple" href="#NonlinearSolve.RadiusUpdateSchemes.Simple"><code>NonlinearSolve.RadiusUpdateSchemes.Simple</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>RadiusUpdateSchemes.Simple</code></p><p>The simple or conventional radius update scheme. This scheme is chosen by default and follows the conventional approach to update the trust region radius, i.e. if the trial step is accepted it increases the radius by a fixed factor (bounded by a maximum radius) and if the trial step is rejected, it shrinks the radius by a fixed factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/aedd385e0f527d05972ad3573ae95af1208eacd3/src/trustRegion.jl#L18-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearSolve.RadiusUpdateSchemes.Hei" href="#NonlinearSolve.RadiusUpdateSchemes.Hei"><code>NonlinearSolve.RadiusUpdateSchemes.Hei</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>RadiusUpdateSchemes.Hei</code></p><p>This scheme is proposed by <a href="https://www.jstor.org/stable/43693061">Hei, L.</a>. The trust region radius depends on the size (norm) of the current step size. The hypothesis is to let the radius converge to zero as the iterations progress, which is more reliable and robust for ill-conditioned as well as degenerate problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/aedd385e0f527d05972ad3573ae95af1208eacd3/src/trustRegion.jl#L28-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearSolve.RadiusUpdateSchemes.Yuan" href="#NonlinearSolve.RadiusUpdateSchemes.Yuan"><code>NonlinearSolve.RadiusUpdateSchemes.Yuan</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>RadiusUpdateSchemes.Yuan</code></p><p>This scheme is proposed by <a href="https://www.researchgate.net/publication/249011466_A_new_trust_region_algorithm_with_trust_region_radius_converging_to_zero">Yuan, Y.</a>. Similar to Hei&#39;s scheme, the trust region is updated in a way so that it converges to zero, however here, the radius depends on the size (norm) of the current gradient of the objective (merit) function. The hypothesis is that the step size is bounded by the gradient size, so it makes sense to let the radius depend on the gradient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/aedd385e0f527d05972ad3573ae95af1208eacd3/src/trustRegion.jl#L38-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearSolve.RadiusUpdateSchemes.Bastin" href="#NonlinearSolve.RadiusUpdateSchemes.Bastin"><code>NonlinearSolve.RadiusUpdateSchemes.Bastin</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>RadiusUpdateSchemes.Bastin</code></p><p>This scheme is proposed by <a href="https://www.researchgate.net/publication/225100660_A_retrospective_trust-region_method_for_unconstrained_optimization">Bastin, et al.</a>. The scheme is called a retrospective update scheme as it uses the model function at the current iteration to compute the ratio of the actual reduction and the predicted reduction in the previous trial step, and use this ratio to update the trust region radius. The hypothesis is to exploit the information made available during the optimization process in order to vary the accuracy of the objective function computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/aedd385e0f527d05972ad3573ae95af1208eacd3/src/trustRegion.jl#L48-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NonlinearSolve.RadiusUpdateSchemes.Fan" href="#NonlinearSolve.RadiusUpdateSchemes.Fan"><code>NonlinearSolve.RadiusUpdateSchemes.Fan</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>RadiusUpdateSchemes.Fan</code></p><p>This scheme is proposed by <a href="https://link.springer.com/article/10.1007/s10589-005-3078-8">Fan, J.</a>. It is very much similar to Hei&#39;s and Yuan&#39;s schemes as it lets the trust region radius depend on the current size (norm) of the objective (merit) function itself. These new update schemes are known to improve local convergence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/aedd385e0f527d05972ad3573ae95af1208eacd3/src/trustRegion.jl#L59-L65">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../solvers/SteadyStateSolvers/">« Steady State Solvers</a><a class="docs-footer-nextpage" href="../simplenonlinearsolve/">SimpleNonlinearSolve.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 29 August 2023 20:20">Tuesday 29 August 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
