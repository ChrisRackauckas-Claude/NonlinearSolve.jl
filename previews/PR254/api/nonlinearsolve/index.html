<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>NonlinearSolve.jl Native Solvers · NonlinearSolve.jl</title><meta name="title" content="NonlinearSolve.jl Native Solvers · NonlinearSolve.jl"/><meta property="og:title" content="NonlinearSolve.jl Native Solvers · NonlinearSolve.jl"/><meta property="twitter:title" content="NonlinearSolve.jl Native Solvers · NonlinearSolve.jl"/><meta name="description" content="Documentation for NonlinearSolve.jl."/><meta property="og:description" content="Documentation for NonlinearSolve.jl."/><meta property="twitter:description" content="Documentation for NonlinearSolve.jl."/><meta property="og:url" content="https://docs.sciml.ai/NonlinearSolve/stable/api/nonlinearsolve/"/><meta property="twitter:url" content="https://docs.sciml.ai/NonlinearSolve/stable/api/nonlinearsolve/"/><link rel="canonical" href="https://docs.sciml.ai/NonlinearSolve/stable/api/nonlinearsolve/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="NonlinearSolve.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NonlinearSolve.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers</a></li><li><a class="tocitem" href="../../tutorials/getting_started/">Getting Started with Nonlinear Rootfinding in Julia</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/code_optimization/">Code Optimization for Small Nonlinear Systems</a></li><li><a class="tocitem" href="../../tutorials/large_systems/">Handling Large Ill-Conditioned and Sparse Systems</a></li><li><a class="tocitem" href="../../tutorials/modelingtoolkit/">Symbolic System Definition and Acceleration via ModelingToolkit</a></li><li><a class="tocitem" href="../../tutorials/small_compile/">Faster Startup and and Static Compilation</a></li><li><a class="tocitem" href="../../tutorials/termination_conditions/">More Detailed Termination Conditions</a></li><li><a class="tocitem" href="../../tutorials/iterator_interface/">Nonlinear Solver Iterator Interface</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/NonlinearProblem/">Nonlinear Problems</a></li><li><a class="tocitem" href="../../basics/NonlinearFunctions/">NonlinearFunctions and Jacobian Types</a></li><li><a class="tocitem" href="../../basics/solve/">Common Solver Options (Solve Keyword Arguments)</a></li><li><a class="tocitem" href="../../basics/NonlinearSolution/">Nonlinear Solutions</a></li><li><a class="tocitem" href="../../basics/TerminationCondition/">Termination Conditions</a></li><li><a class="tocitem" href="../../basics/FAQ/">Frequently Asked Questions</a></li></ul></li><li><span class="tocitem">Solver Summaries and Recommendations</span><ul><li><a class="tocitem" href="../../solvers/NonlinearSystemSolvers/">Nonlinear System Solvers</a></li><li><a class="tocitem" href="../../solvers/BracketingSolvers/">Interval Rootfinding Methods (Bracketing Solvers)</a></li><li><a class="tocitem" href="../../solvers/SteadyStateSolvers/">Steady State Solvers</a></li><li><a class="tocitem" href="../../solvers/NonlinearLeastSquaresSolvers/">Nonlinear Least Squares Solvers</a></li></ul></li><li><span class="tocitem">Detailed Solver APIs</span><ul><li class="is-active"><a class="tocitem" href>NonlinearSolve.jl Native Solvers</a><ul class="internal"><li><a class="tocitem" href="#Core-Nonlinear-Solvers"><span>Core Nonlinear Solvers</span></a></li><li><a class="tocitem" href="#Polyalgorithms"><span>Polyalgorithms</span></a></li><li><a class="tocitem" href="#Nonlinear-Least-Squares-Solvers"><span>Nonlinear Least Squares Solvers</span></a></li><li><a class="tocitem" href="#Radius-Update-Schemes-for-Trust-Region-(RadiusUpdateSchemes)"><span>Radius Update Schemes for Trust Region (RadiusUpdateSchemes)</span></a></li></ul></li><li><a class="tocitem" href="../simplenonlinearsolve/">SimpleNonlinearSolve.jl</a></li><li><a class="tocitem" href="../minpack/">MINPACK.jl</a></li><li><a class="tocitem" href="../nlsolve/">NLsolve.jl</a></li><li><a class="tocitem" href="../sundials/">Sundials.jl</a></li><li><a class="tocitem" href="../steadystatediffeq/">SteadyStateDiffEq.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Detailed Solver APIs</a></li><li class="is-active"><a href>NonlinearSolve.jl Native Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>NonlinearSolve.jl Native Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/NonlinearSolve.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/NonlinearSolve.jl/blob/master/docs/src/api/nonlinearsolve.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="NonlinearSolve.jl-Native-Solvers"><a class="docs-heading-anchor" href="#NonlinearSolve.jl-Native-Solvers">NonlinearSolve.jl Native Solvers</a><a id="NonlinearSolve.jl-Native-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#NonlinearSolve.jl-Native-Solvers" title="Permalink"></a></h1><p>These are the native solvers of NonlinearSolve.jl.</p><h2 id="Core-Nonlinear-Solvers"><a class="docs-heading-anchor" href="#Core-Nonlinear-Solvers">Core Nonlinear Solvers</a><a id="Core-Nonlinear-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Nonlinear-Solvers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.NewtonRaphson" href="#NonlinearSolve.NewtonRaphson"><code>NonlinearSolve.NewtonRaphson</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NewtonRaphson(; concrete_jac = nothing, linsolve = nothing,
    precs = DEFAULT_PRECS, adkwargs...)</code></pre><p>An advanced NewtonRaphson implementation with support for efficient handling of sparse matrices via colored automatic differentiation and preconditioned linear solvers. Designed for large-scale and numerically-difficult nonlinear systems.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: determines the backend used for the Jacobian. Note that this argument is ignored if an analytical Jacobian is passed, as that will be used instead. Defaults to <code>nothing</code> which means that a default is selected according to the problem specification! Valid choices are types from ADTypes.jl.</li><li><code>concrete_jac</code>: whether to build a concrete Jacobian. If a Krylov-subspace method is used, then the Jacobian will not be constructed and instead direct Jacobian-vector products <code>J*v</code> are computed using forward-mode automatic differentiation or finite differencing tricks (without ever constructing the Jacobian). However, if the Jacobian is still needed, for example for a preconditioner, <code>concrete_jac = true</code> can be passed in order to force the construction of the Jacobian.</li><li><code>linsolve</code>: the <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> used for the linear solves within the Newton method. Defaults to <code>nothing</code>, which means it uses the LinearSolve.jl default algorithm choice. For more information on available algorithm choices, see the <a href="https://docs.sciml.ai/LinearSolve/stable/">LinearSolve.jl documentation</a>.</li><li><code>precs</code>: the choice of preconditioners for the linear solver. Defaults to using no preconditioners. For more information on specifying preconditioners for LinearSolve algorithms, consult the <a href="https://docs.sciml.ai/LinearSolve/stable/">LinearSolve.jl documentation</a>.</li><li><code>linesearch</code>: the line search algorithm to use. Defaults to <a href="@ref"><code>LineSearch()</code></a>, which means that no line search is performed. Algorithms from <code>LineSearches.jl</code> can be used here directly, and they will be converted to the correct <code>LineSearch</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/df0bffe9f3b801419be8c3d4d2128ad4f15c9ebd/src/raphson.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.TrustRegion" href="#NonlinearSolve.TrustRegion"><code>NonlinearSolve.TrustRegion</code></a> — <span class="docstring-category">Type</span></header><section><div><p>```julia     TrustRegion(; concrete<em>jac = nothing, linsolve = nothing, precs = DEFAULT</em>PRECS,         radius<em>update</em>scheme::RadiusUpdateSchemes.T = RadiusUpdateSchemes.Simple,         max<em>trust</em>radius::Real = 0 // 1, initial<em>trust</em>radius::Real = 0 // 1,         step<em>threshold::Real = 1 // 10, shrink</em>threshold::Real = 1 // 4,         expand<em>threshold::Real = 3 // 4, shrink</em>factor::Real = 1 // 4,         expand<em>factor::Real = 2 // 1, max</em>shrink_times::Int = 32, adkwargs...)</p><p>An advanced TrustRegion implementation with support for efficient handling of sparse matrices via colored automatic differentiation and preconditioned linear solvers. Designed for large-scale and numerically-difficult nonlinear systems.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: determines the backend used for the Jacobian. Note that this argument is ignored if an analytical Jacobian is passed, as that will be used instead. Defaults to <code>nothing</code> which means that a default is selected according to the problem specification!. Valid choices are types from ADTypes.jl.</li><li><code>concrete_jac</code>: whether to build a concrete Jacobian. If a Krylov-subspace method is used, then the Jacobian will not be constructed and instead direct Jacobian-vector products <code>J*v</code> are computed using forward-mode automatic differentiation or finite differencing tricks (without ever constructing the Jacobian). However, if the Jacobian is still needed, for example for a preconditioner, <code>concrete_jac = true</code> can be passed in order to force the construction of the Jacobian.</li><li><code>linsolve</code>: the <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> used for the linear solves within the Newton method. Defaults to <code>nothing</code>, which means it uses the LinearSolve.jl default algorithm choice. For more information on available algorithm choices, see the <a href="https://docs.sciml.ai/LinearSolve/stable/">LinearSolve.jl documentation</a>.</li><li><code>precs</code>: the choice of preconditioners for the linear solver. Defaults to using no preconditioners. For more information on specifying preconditioners for LinearSolve algorithms, consult the <a href="https://docs.sciml.ai/LinearSolve/stable/">LinearSolve.jl documentation</a>.</li><li><code>radius_update_scheme</code>: the choice of radius update scheme to be used. Defaults to <code>RadiusUpdateSchemes.Simple</code> which follows the conventional approach. Other available schemes are <code>RadiusUpdateSchemes.Hei</code>, <code>RadiusUpdateSchemes.Yuan</code>, <code>RadiusUpdateSchemes.Bastin</code>, <code>RadiusUpdateSchemes.Fan</code>. These schemes have the trust region radius converging to zero that is seen to improve convergence. For more details, see the <a href="https://link.springer.com/article/10.1007/s10107-015-0893-2#Sec4">Yuan, Yx</a>.</li><li><code>max_trust_radius</code>: the maximal trust region radius. Defaults to <code>max(norm(fu), maximum(u) - minimum(u))</code>.</li><li><code>initial_trust_radius</code>: the initial trust region radius. Defaults to <code>max_trust_radius / 11</code>.</li><li><code>step_threshold</code>: the threshold for taking a step. In every iteration, the threshold is compared with a value <code>r</code>, which is the actual reduction in the objective function divided by the predicted reduction. If <code>step_threshold &gt; r</code> the model is not a good approximation, and the step is rejected. Defaults to <code>0.1</code>. For more details, see <a href="https://link.springer.com/article/10.1007/s40096-020-00339-4">Rahpeymaii, F.</a></li><li><code>shrink_threshold</code>: the threshold for shrinking the trust region radius. In every iteration, the threshold is compared with a value <code>r</code> which is the actual reduction in the objective function divided by the predicted reduction. If <code>shrink_threshold &gt; r</code> the trust region radius is shrunk by <code>shrink_factor</code>. Defaults to <code>0.25</code>. For more details, see <a href="https://link.springer.com/article/10.1007/s40096-020-00339-4">Rahpeymaii, F.</a></li><li><code>expand_threshold</code>: the threshold for expanding the trust region radius. If a step is taken, i.e <code>step_threshold &lt; r</code> (with <code>r</code> defined in <code>shrink_threshold</code>), a check is also made to see if <code>expand_threshold &lt; r</code>. If that is true, the trust region radius is expanded by <code>expand_factor</code>. Defaults to <code>0.75</code>.</li><li><code>shrink_factor</code>: the factor to shrink the trust region radius with if <code>shrink_threshold &gt; r</code> (with <code>r</code> defined in <code>shrink_threshold</code>). Defaults to <code>0.25</code>.</li><li><code>expand_factor</code>: the factor to expand the trust region radius with if <code>expand_threshold &lt; r</code> (with <code>r</code> defined in <code>shrink_threshold</code>). Defaults to <code>2.0</code>.</li><li><code>max_shrink_times</code>: the maximum number of times to shrink the trust region radius in a row, <code>max_shrink_times</code> is exceeded, the algorithm returns. Defaults to <code>32</code>.</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>linsolve</code> and <code>precs</code> are used exclusively for the inplace version of the algorithm. Support for the OOP version is planned!</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/df0bffe9f3b801419be8c3d4d2128ad4f15c9ebd/src/trustRegion.jl#L83-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.PseudoTransient" href="#NonlinearSolve.PseudoTransient"><code>NonlinearSolve.PseudoTransient</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PseudoTransient(; concrete_jac = nothing, linsolve = nothing,
    precs = DEFAULT_PRECS, alpha_initial = 1e-3, adkwargs...)</code></pre><p>An implementation of PseudoTransient method that is used to solve steady state problems in an accelerated manner. It uses an adaptive time-stepping to integrate an initial value of nonlinear problem until sufficient accuracy in the desired steady-state is achieved to switch over to Newton&#39;s method and  gain a rapid convergence. This implementation specifically uses &quot;switched evolution relaxation&quot; SER method. For detail information about the time-stepping and algorithm, please see the paper: <a href="https://doi.org/10.1137/S106482750241044X">Coffey, Todd S. and Kelley, C. T. and Keyes, David E. (2003), Pseudotransient Continuation and Differential-Algebraic Equations,  SIAM Journal on Scientific Computing,25, 553-569.</a></p><p><strong>Keyword Arguments</strong></p><ul><li><code>alpha_initial</code> : the initial pseudo time step. it defaults to 1e-3. If it is small, you are going to need more iterations to converge.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/df0bffe9f3b801419be8c3d4d2128ad4f15c9ebd/src/pseudotransient.jl#L1-L18">source</a></section></article><h2 id="Polyalgorithms"><a class="docs-heading-anchor" href="#Polyalgorithms">Polyalgorithms</a><a id="Polyalgorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Polyalgorithms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.FastShortcutNonlinearPolyalg" href="#NonlinearSolve.FastShortcutNonlinearPolyalg"><code>NonlinearSolve.FastShortcutNonlinearPolyalg</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FastShortcutNonlinearPolyalg(; concrete_jac = nothing, linsolve = nothing,
                               precs = DEFAULT_PRECS, adkwargs...)</code></pre><p>A polyalgorithm focused on balancing speed and robustness. It first tries less robust methods for more performance and then tries more robust techniques if the faster ones fail.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: determines the backend used for the Jacobian. Note that this argument is ignored if an analytical Jacobian is passed, as that will be used instead. Defaults to <code>AutoForwardDiff()</code>. Valid choices are types from ADTypes.jl.</li><li><code>concrete_jac</code>: whether to build a concrete Jacobian. If a Krylov-subspace method is used, then the Jacobian will not be constructed and instead direct Jacobian-vector products <code>J*v</code> are computed using forward-mode automatic differentiation or finite differencing tricks (without ever constructing the Jacobian). However, if the Jacobian is still needed, for example for a preconditioner, <code>concrete_jac = true</code> can be passed in order to force the construction of the Jacobian.</li><li><code>linsolve</code>: the <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> used for the linear solves within the Newton method. Defaults to <code>nothing</code>, which means it uses the LinearSolve.jl default algorithm choice. For more information on available algorithm choices, see the <a href="https://docs.sciml.ai/LinearSolve/stable/">LinearSolve.jl documentation</a>.</li><li><code>precs</code>: the choice of preconditioners for the linear solver. Defaults to using no preconditioners. For more information on specifying preconditioners for LinearSolve algorithms, consult the <a href="https://docs.sciml.ai/LinearSolve/stable/">LinearSolve.jl documentation</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/df0bffe9f3b801419be8c3d4d2128ad4f15c9ebd/src/default.jl#L74-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.RobustMultiNewton" href="#NonlinearSolve.RobustMultiNewton"><code>NonlinearSolve.RobustMultiNewton</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RobustMultiNewton(; concrete_jac = nothing, linsolve = nothing, precs = DEFAULT_PRECS,
                    adkwargs...)</code></pre><p>A polyalgorithm focused on robustness. It uses a mixture of Newton methods with different globalizing techniques (trust region updates, line searches, etc.) in order to find a method that is able to adequately solve the minimization problem.</p><p>Basically, if this algorithm fails, then &quot;most&quot; good ways of solving your problem fail and you may need to think about reformulating the model (either there is an issue with the model, or more precision / more stable linear solver choice is required).</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: determines the backend used for the Jacobian. Note that this argument is ignored if an analytical Jacobian is passed, as that will be used instead. Defaults to <code>AutoForwardDiff()</code>. Valid choices are types from ADTypes.jl.</li><li><code>concrete_jac</code>: whether to build a concrete Jacobian. If a Krylov-subspace method is used, then the Jacobian will not be constructed and instead direct Jacobian-vector products <code>J*v</code> are computed using forward-mode automatic differentiation or finite differencing tricks (without ever constructing the Jacobian). However, if the Jacobian is still needed, for example for a preconditioner, <code>concrete_jac = true</code> can be passed in order to force the construction of the Jacobian.</li><li><code>linsolve</code>: the <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> used for the linear solves within the Newton method. Defaults to <code>nothing</code>, which means it uses the LinearSolve.jl default algorithm choice. For more information on available algorithm choices, see the <a href="https://docs.sciml.ai/LinearSolve/stable/">LinearSolve.jl documentation</a>.</li><li><code>precs</code>: the choice of preconditioners for the linear solver. Defaults to using no preconditioners. For more information on specifying preconditioners for LinearSolve algorithms, consult the <a href="https://docs.sciml.ai/LinearSolve/stable/">LinearSolve.jl documentation</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/df0bffe9f3b801419be8c3d4d2128ad4f15c9ebd/src/default.jl#L1-L32">source</a></section></article><h2 id="Nonlinear-Least-Squares-Solvers"><a class="docs-heading-anchor" href="#Nonlinear-Least-Squares-Solvers">Nonlinear Least Squares Solvers</a><a id="Nonlinear-Least-Squares-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-Least-Squares-Solvers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.LevenbergMarquardt" href="#NonlinearSolve.LevenbergMarquardt"><code>NonlinearSolve.LevenbergMarquardt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LevenbergMarquardt(; concrete_jac = nothing, linsolve = nothing,
    precs = DEFAULT_PRECS, damping_initial::Real = 1.0,
    damping_increase_factor::Real = 2.0, damping_decrease_factor::Real = 3.0,
    finite_diff_step_geodesic::Real = 0.1, α_geodesic::Real = 0.75,
    b_uphill::Real = 1.0, min_damping_D::AbstractFloat = 1e-8, adkwargs...)</code></pre><p>An advanced Levenberg-Marquardt implementation with the improvements suggested in the <a href="https://arxiv.org/abs/1201.5885">paper</a> &quot;Improvements to the Levenberg-Marquardt algorithm for nonlinear least-squares minimization&quot;. Designed for large-scale and numerically-difficult nonlinear systems.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: determines the backend used for the Jacobian. Note that this argument is ignored if an analytical Jacobian is passed, as that will be used instead. Defaults to <code>nothing</code> which means that a default is selected according to the problem specification! Valid choices are types from ADTypes.jl.</li><li><code>concrete_jac</code>: whether to build a concrete Jacobian. If a Krylov-subspace method is used, then the Jacobian will not be constructed and instead direct Jacobian-vector products <code>J*v</code> are computed using forward-mode automatic differentiation or finite differencing tricks (without ever constructing the Jacobian). However, if the Jacobian is still needed, for example for a preconditioner, <code>concrete_jac = true</code> can be passed in order to force the construction of the Jacobian.</li><li><code>linsolve</code>: the <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> used for the linear solves within the Newton method. Defaults to <code>nothing</code>, which means it uses the LinearSolve.jl default algorithm choice. For more information on available algorithm choices, see the <a href="https://docs.sciml.ai/LinearSolve/stable/">LinearSolve.jl documentation</a>.</li><li><code>precs</code>: the choice of preconditioners for the linear solver. Defaults to using no preconditioners. For more information on specifying preconditioners for LinearSolve algorithms, consult the <a href="https://docs.sciml.ai/LinearSolve/stable/">LinearSolve.jl documentation</a>.</li><li><code>damping_initial</code>: the starting value for the damping factor. The damping factor is inversely proportional to the step size. The damping factor is adjusted during each iteration. Defaults to <code>1.0</code>. For more details, see section 2.1 of <a href="https://arxiv.org/abs/1201.5885">this paper</a>.</li><li><code>damping_increase_factor</code>: the factor by which the damping is increased if a step is rejected. Defaults to <code>2.0</code>. For more details, see section 2.1 of <a href="https://arxiv.org/abs/1201.5885">this paper</a>.</li><li><code>damping_decrease_factor</code>: the factor by which the damping is decreased if a step is accepted. Defaults to <code>3.0</code>. For more details, see section 2.1 of <a href="https://arxiv.org/abs/1201.5885">this paper</a>.</li><li><code>finite_diff_step_geodesic</code>: the step size used for finite differencing used to calculate the geodesic acceleration. Defaults to <code>0.1</code> which means that the step size is approximately 10% of the first-order step. For more details, see section 3 of <a href="https://arxiv.org/abs/1201.5885">this paper</a>.</li><li><code>α_geodesic</code>: a factor that determines if a step is accepted or rejected. To incorporate geodesic acceleration as an addition to the Levenberg-Marquardt algorithm, it is necessary that acceptable steps meet the condition <span>$\frac{2||a||}{||v||} \le \alpha_{\text{geodesic}}$</span>, where <span>$a$</span> is the geodesic acceleration, <span>$v$</span> is the Levenberg-Marquardt algorithm&#39;s step (velocity along a geodesic path) and <code>α_geodesic</code> is some number of order <code>1</code>. For most problems <code>α_geodesic = 0.75</code> is a good value but for problems where convergence is difficult <code>α_geodesic = 0.1</code> is an effective choice. Defaults to <code>0.75</code>. For more details, see section 3, equation (15) of <a href="https://arxiv.org/abs/1201.5885">this paper</a>.</li><li><code>b_uphill</code>: a factor that determines if a step is accepted or rejected. The standard choice in the Levenberg-Marquardt method is to accept all steps that decrease the cost and reject all steps that increase the cost. Although this is a natural and safe choice, it is often not the most efficient. Therefore downhill moves are always accepted, but uphill moves are only conditionally accepted. To decide whether an uphill move will be accepted at each iteration <span>$i$</span>, we compute <span>$\beta_i = \cos(v_{\text{new}}, v_{\text{old}})$</span>, which denotes the cosine angle between the proposed velocity <span>$v_{\text{new}}$</span> and the velocity of the last accepted step <span>$v_{\text{old}}$</span>. The idea is to accept uphill moves if the angle is small. To specify, uphill moves are accepted if <span>$(1-\beta_i)^{b_{\text{uphill}}} C_{i+1} \le C_i$</span>, where <span>$C_i$</span> is the cost at iteration <span>$i$</span>. Reasonable choices for <code>b_uphill</code> are <code>1.0</code> or <code>2.0</code>, with <code>b_uphill=2.0</code> allowing higher uphill moves than <code>b_uphill=1.0</code>. When <code>b_uphill=0.0</code>, no uphill moves will be accepted. Defaults to <code>1.0</code>. For more details, see section 4 of <a href="https://arxiv.org/abs/1201.5885">this paper</a>.</li><li><code>min_damping_D</code>: the minimum value of the damping terms in the diagonal damping matrix <code>DᵀD</code>, where <code>DᵀD</code> is given by the largest diagonal entries of <code>JᵀJ</code> yet encountered, where <code>J</code> is the Jacobian. It is suggested by <a href="https://arxiv.org/abs/1201.5885">this paper</a> to use a minimum value of the elements in <code>DᵀD</code> to prevent the damping from being too small. Defaults to <code>1e-8</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/df0bffe9f3b801419be8c3d4d2128ad4f15c9ebd/src/levenberg.jl#L1-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.GaussNewton" href="#NonlinearSolve.GaussNewton"><code>NonlinearSolve.GaussNewton</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussNewton(; concrete_jac = nothing, linsolve = nothing,
    precs = DEFAULT_PRECS, adkwargs...)</code></pre><p>An advanced GaussNewton implementation with support for efficient handling of sparse matrices via colored automatic differentiation and preconditioned linear solvers. Designed for large-scale and numerically-difficult nonlinear least squares problems.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In most practical situations, users should prefer using <code>LevenbergMarquardt</code> instead! It is a more general extension of <code>Gauss-Newton</code> Method.</p></div></div><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: determines the backend used for the Jacobian. Note that this argument is ignored if an analytical Jacobian is passed, as that will be used instead. Defaults to <code>nothing</code> which means that a default is selected according to the problem specification! Valid choices are types from ADTypes.jl.</li><li><code>concrete_jac</code>: whether to build a concrete Jacobian. If a Krylov-subspace method is used, then the Jacobian will not be constructed and instead direct Jacobian-vector products <code>J*v</code> are computed using forward-mode automatic differentiation or finite differencing tricks (without ever constructing the Jacobian). However, if the Jacobian is still needed, for example for a preconditioner, <code>concrete_jac = true</code> can be passed in order to force the construction of the Jacobian.</li><li><code>linsolve</code>: the <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> used for the linear solves within the Newton method. Defaults to <code>nothing</code>, which means it uses the LinearSolve.jl default algorithm choice. For more information on available algorithm choices, see the <a href="https://docs.sciml.ai/LinearSolve/stable/">LinearSolve.jl documentation</a>.</li><li><code>precs</code>: the choice of preconditioners for the linear solver. Defaults to using no preconditioners. For more information on specifying preconditioners for LinearSolve algorithms, consult the <a href="https://docs.sciml.ai/LinearSolve/stable/">LinearSolve.jl documentation</a>.</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Jacobian-Free version of <code>GaussNewton</code> doesn&#39;t work yet, and it forces jacobian construction. This will be fixed in the near future.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/df0bffe9f3b801419be8c3d4d2128ad4f15c9ebd/src/gaussnewton.jl#L1-L38">source</a></section></article><h2 id="Radius-Update-Schemes-for-Trust-Region-(RadiusUpdateSchemes)"><a class="docs-heading-anchor" href="#Radius-Update-Schemes-for-Trust-Region-(RadiusUpdateSchemes)">Radius Update Schemes for Trust Region (RadiusUpdateSchemes)</a><a id="Radius-Update-Schemes-for-Trust-Region-(RadiusUpdateSchemes)-1"></a><a class="docs-heading-anchor-permalink" href="#Radius-Update-Schemes-for-Trust-Region-(RadiusUpdateSchemes)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.RadiusUpdateSchemes" href="#NonlinearSolve.RadiusUpdateSchemes"><code>NonlinearSolve.RadiusUpdateSchemes</code></a> — <span class="docstring-category">Module</span></header><section><div><p><code>RadiusUpdateSchemes</code></p><p><code>RadiusUpdateSchemes</code> is the standard enum interface for different types of radius update schemes implemented in the Trust Region method. These schemes specify how the radius of the so-called trust region is updated after each iteration of the algorithm. The specific role and caveats associated with each scheme are provided below.</p><p><strong>Using <code>RadiusUpdateSchemes</code></strong></p><p><code>RadiusUpdateSchemes</code> uses the standard EnumX interface (https://github.com/fredrikekre/EnumX.jl), and hence inherits all properties of being an EnumX, including the type of each constituent enum states as <code>RadiusUpdateSchemes.T</code>. Simply put the desired scheme as follows: <code>TrustRegion(radius_update_scheme = your desired update scheme)</code>. For example, <code>sol = solve(prob, alg=TrustRegion(radius_update_scheme = RadiusUpdateSchemes.Hei))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/df0bffe9f3b801419be8c3d4d2128ad4f15c9ebd/src/trustRegion.jl#L1-L16">source</a></section></article><h3 id="Available-Radius-Update-Schemes"><a class="docs-heading-anchor" href="#Available-Radius-Update-Schemes">Available Radius Update Schemes</a><a id="Available-Radius-Update-Schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Available-Radius-Update-Schemes" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.RadiusUpdateSchemes.Simple" href="#NonlinearSolve.RadiusUpdateSchemes.Simple"><code>NonlinearSolve.RadiusUpdateSchemes.Simple</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>RadiusUpdateSchemes.Simple</code></p><p>The simple or conventional radius update scheme. This scheme is chosen by default and follows the conventional approach to update the trust region radius, i.e. if the trial step is accepted it increases the radius by a fixed factor (bounded by a maximum radius) and if the trial step is rejected, it shrinks the radius by a fixed factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/df0bffe9f3b801419be8c3d4d2128ad4f15c9ebd/src/trustRegion.jl#L18-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.RadiusUpdateSchemes.Hei" href="#NonlinearSolve.RadiusUpdateSchemes.Hei"><code>NonlinearSolve.RadiusUpdateSchemes.Hei</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>RadiusUpdateSchemes.Hei</code></p><p>This scheme is proposed by <a href="https://www.jstor.org/stable/43693061">Hei, L.</a>. The trust region radius depends on the size (norm) of the current step size. The hypothesis is to let the radius converge to zero as the iterations progress, which is more reliable and robust for ill-conditioned as well as degenerate problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/df0bffe9f3b801419be8c3d4d2128ad4f15c9ebd/src/trustRegion.jl#L42-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.RadiusUpdateSchemes.Yuan" href="#NonlinearSolve.RadiusUpdateSchemes.Yuan"><code>NonlinearSolve.RadiusUpdateSchemes.Yuan</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>RadiusUpdateSchemes.Yuan</code></p><p>This scheme is proposed by <a href="https://www.researchgate.net/publication/249011466_A_new_trust_region_algorithm_with_trust_region_radius_converging_to_zero">Yuan, Y.</a>. Similar to Hei&#39;s scheme, the trust region is updated in a way so that it converges to zero, however here, the radius depends on the size (norm) of the current gradient of the objective (merit) function. The hypothesis is that the step size is bounded by the gradient size, so it makes sense to let the radius depend on the gradient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/df0bffe9f3b801419be8c3d4d2128ad4f15c9ebd/src/trustRegion.jl#L52-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.RadiusUpdateSchemes.Bastin" href="#NonlinearSolve.RadiusUpdateSchemes.Bastin"><code>NonlinearSolve.RadiusUpdateSchemes.Bastin</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>RadiusUpdateSchemes.Bastin</code></p><p>This scheme is proposed by <a href="https://www.researchgate.net/publication/225100660_A_retrospective_trust-region_method_for_unconstrained_optimization">Bastin, et al.</a>. The scheme is called a retrospective update scheme as it uses the model function at the current iteration to compute the ratio of the actual reduction and the predicted reduction in the previous trial step, and use this ratio to update the trust region radius. The hypothesis is to exploit the information made available during the optimization process in order to vary the accuracy of the objective function computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/df0bffe9f3b801419be8c3d4d2128ad4f15c9ebd/src/trustRegion.jl#L62-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonlinearSolve.RadiusUpdateSchemes.Fan" href="#NonlinearSolve.RadiusUpdateSchemes.Fan"><code>NonlinearSolve.RadiusUpdateSchemes.Fan</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>RadiusUpdateSchemes.Fan</code></p><p>This scheme is proposed by <a href="https://link.springer.com/article/10.1007/s10589-005-3078-8">Fan, J.</a>. It is very much similar to Hei&#39;s and Yuan&#39;s schemes as it lets the trust region radius depend on the current size (norm) of the objective (merit) function itself. These new update schemes are known to improve local convergence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/NonlinearSolve.jl/blob/df0bffe9f3b801419be8c3d4d2128ad4f15c9ebd/src/trustRegion.jl#L73-L79">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../solvers/NonlinearLeastSquaresSolvers/">« Nonlinear Least Squares Solvers</a><a class="docs-footer-nextpage" href="../simplenonlinearsolve/">SimpleNonlinearSolve.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.1 on <span class="colophon-date" title="Friday 20 October 2023 16:50">Friday 20 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
