var documenterSearchIndex = {"docs":
[{"location":"basics/NonlinearProblem/#Nonlinear-Problems","page":"Nonlinear Problems","title":"Nonlinear Problems","text":"","category":"section"},{"location":"basics/NonlinearProblem/#The-Three-Types-of-Nonlinear-Problems","page":"Nonlinear Problems","title":"The Three Types of Nonlinear Problems","text":"","category":"section"},{"location":"basics/NonlinearProblem/","page":"Nonlinear Problems","title":"Nonlinear Problems","text":"NonlinearSolve.jl tackles two related types of nonlinear systems:","category":"page"},{"location":"basics/NonlinearProblem/","page":"Nonlinear Problems","title":"Nonlinear Problems","text":"Interval rootfinding problems. I.e., find the t in t_0 t_f such that f(t) = 0.\nSystems of nonlinear equations, i.e. find the u such that f(u) = 0.\nSteady state problems, i.e. find the u such that u' = f(u,t) has reached steady state, i.e. 0 = f(u, ∞).","category":"page"},{"location":"basics/NonlinearProblem/","page":"Nonlinear Problems","title":"Nonlinear Problems","text":"The first is for solving scalar rootfinding problems, i.e. finding a single number, and requires that a bracketing interval is known. For a bracketing interval, one must have that the sign of f(t_0) is opposite the sign of f(t_f), thus guaranteeing a root in the interval.","category":"page"},{"location":"basics/NonlinearProblem/","page":"Nonlinear Problems","title":"Nonlinear Problems","text":"note: Note\nInterval rootfinding problems allow for f to return an array, in which case the interval rootfinding problem is interpreted as finding the first t such that any of the components of the array hit zero.","category":"page"},{"location":"basics/NonlinearProblem/","page":"Nonlinear Problems","title":"Nonlinear Problems","text":"The second type of nonlinear system can be multidimensional and thus no ordering nor boundaries are assumed to be known. For a system of nonlinear equations, f can return an array and the solver seeks to find the value of u for which all outputs of f are simultaniously zero.","category":"page"},{"location":"basics/NonlinearProblem/","page":"Nonlinear Problems","title":"Nonlinear Problems","text":"The last type if equivalent to a nonlinear system but with the extra interpretion of having a potentially preferred unique root. That is, when there are multiple u such that f(u) = 0, the NonlinearProblem does not have a preferred solution, while for the SteadyStateProblem the preferred solution is the u(∞) that would arise from solving the ODE u' = f(u,t).","category":"page"},{"location":"basics/NonlinearProblem/","page":"Nonlinear Problems","title":"Nonlinear Problems","text":"warn: Warn\nMost solvers for SteadyStateProblem do not guarentee the preferred solution and instead will solve for some u in the set of solutions. The documentation of the nonlinear solvers will note if they return the preferred solution.","category":"page"},{"location":"basics/NonlinearProblem/#Problem-Construction-Details","page":"Nonlinear Problems","title":"Problem Construction Details","text":"","category":"section"},{"location":"basics/NonlinearProblem/","page":"Nonlinear Problems","title":"Nonlinear Problems","text":"SciMLBase.IntervalNonlinearProblem\nSciMLBase.NonlinearProblem\nSciMLBase.SteadyStateProblem","category":"page"},{"location":"basics/NonlinearProblem/#SciMLBase.IntervalNonlinearProblem","page":"Nonlinear Problems","title":"SciMLBase.IntervalNonlinearProblem","text":"Defines a interval nonlinear system problem. Documentation Page: https://docs.sciml.ai/NonlinearSolve/stable/basics/NonlinearProblem/\n\nMathematical Specification of a Interval Nonlinear Problem\n\nTo define a Nonlinear Problem, you simply need to give the function f which defines the nonlinear system:\n\nf(tp) = u = 0\n\nalong with an interval tspan is t \\in [t_0,t_f] within which the root should be found. f should be specified as f(t,p) (or in-place as f(u,t,p)), and tspan should be a Tuple{T,T} where T <: Number.\n\nnote: Note\nThe output value u is not required to be a scalar. When u is an AbstractArray, the problem is a simultanious interval nonlinear problem where the solvers are made to give the first t for which any of the u hit zero. Currently none of the solvers support this mode.\n\nProblem Type\n\nConstructors\n\nIntervalNonlinearProblem(f::NonlinearFunction,tspan,p=NullParameters();kwargs...)\nIntervalNonlinearProblem{isinplace}(f,tspan,p=NullParameters();kwargs...)\n\nisinplace optionally sets whether the function is in-place or not. This is determined automatically, but not inferred.\n\nParameters are optional, and if not given, then a NullParameters() singleton will be used, which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a callback in the problem, then that callback will be added in every solve call.\n\nFields\n\nf: The function in the problem.\ntspan: The interval in which the root is to be found.\np: The parameters for the problem. Defaults to NullParameters.\nkwargs: The keyword arguments passed on to the solvers.\n\n\n\n","category":"type"},{"location":"basics/NonlinearProblem/#SciMLBase.NonlinearProblem","page":"Nonlinear Problems","title":"SciMLBase.NonlinearProblem","text":"Defines a nonlinear system problem. Documentation Page: https://docs.sciml.ai/NonlinearSolve/stable/basics/NonlinearProblem/\n\nMathematical Specification of a Nonlinear Problem\n\nTo define a Nonlinear Problem, you simply need to give the function f which defines the nonlinear system:\n\nf(up) = 0\n\nand an initial guess u₀ of where f(u,p)=0. f should be specified as f(u,p) (or in-place as f(du,u,p)), and u₀ should be an AbstractArray (or number) whose geometry matches the desired geometry of u. Note that we are not limited to numbers or vectors for u₀; one is allowed to provide u₀ as arbitrary matrices / higher-dimension tensors as well.\n\nProblem Type\n\nConstructors\n\nNonlinearProblem(f::NonlinearFunction,u0,p=NullParameters();kwargs...)\nNonlinearProblem{isinplace}(f,u0,p=NullParameters();kwargs...)\n\nisinplace optionally sets whether the function is in-place or not. This is determined automatically, but not inferred.\n\nParameters are optional, and if not given, then a NullParameters() singleton will be used, which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a callback in the problem, then that callback will be added in every solve call.\n\nFor specifying Jacobians and mass matrices, see the NonlinearFunctions page.\n\nFields\n\nf: The function in the problem.\nu0: The initial guess for the steady state.\np: The parameters for the problem. Defaults to NullParameters.\nkwargs: The keyword arguments passed on to the solvers.\n\n\n\n","category":"type"},{"location":"basics/NonlinearProblem/#SciMLBase.SteadyStateProblem","page":"Nonlinear Problems","title":"SciMLBase.SteadyStateProblem","text":"Defines an Defines a steady state ODE problem. Documentation Page: https://docs.sciml.ai/DiffEqDocs/stable/types/steadystatetypes/\n\nMathematical Specification of a Steady State Problem\n\nTo define an Steady State Problem, you simply need to give the function f which defines the ODE:\n\nfracdudt = f(upt)\n\nand an initial guess u_0 of where f(u,p,t)=0. f should be specified as f(u,p,t) (or in-place as f(du,u,p,t)), and u₀ should be an AbstractArray (or number) whose geometry matches the desired geometry of u. Note that we are not limited to numbers or vectors for u₀; one is allowed to provide u₀ as arbitrary matrices / higher dimension tensors as well.\n\nNote that for the steady-state to be defined, we must have that f is autonomous, that is f is independent of t. But the form which matches the standard ODE solver should still be used. The steady state solvers interpret the f by fixing t=0.\n\nProblem Type\n\nConstructors\n\nSteadyStateProblem(f::ODEFunction,u0,p=NullParameters();kwargs...)\nSteadyStateProblem{isinplace,specialize}(f,u0,p=NullParameters();kwargs...)\n\nisinplace optionally sets whether the function is inplace or not. This is  determined automatically, but not inferred. specialize optionally controls  the specialization level. See the specialization levels section of the SciMLBase documentation for more details. The default is `AutoSpecialize.\n\nParameters are optional, and if not given then a NullParameters() singleton will be used which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a callback in the problem, then that callback will be added in every solve call.\n\nAdditionally, the constructor from ODEProblems is provided:\n\nSteadyStateProblem(prob::ODEProblem)\n\nParameters are optional, and if not given then a NullParameters() singleton will be used which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a callback in the problem, then that callback will be added in every solve call.\n\nFor specifying Jacobians and mass matrices, see the DiffEqFunctions page.\n\nFields\n\nf: The function in the ODE.\nu0: The initial guess for the steady state.\np: The parameters for the problem. Defaults to NullParameters\nkwargs: The keyword arguments passed onto the solves.\n\nSpecial Solution Fields\n\nThe SteadyStateSolution type is different from the other DiffEq solutions because it does not have temporal information.\n\n\n\n","category":"type"},{"location":"basics/NonlinearSolution/#Nonlinear-Solutions","page":"Nonlinear Solutions","title":"Nonlinear Solutions","text":"","category":"section"},{"location":"basics/NonlinearSolution/","page":"Nonlinear Solutions","title":"Nonlinear Solutions","text":"SciMLBase.NonlinearSolution","category":"page"},{"location":"basics/NonlinearSolution/#SciMLBase.NonlinearSolution","page":"Nonlinear Solutions","title":"SciMLBase.NonlinearSolution","text":"struct NonlinearSolution{T, N, uType, R, P, A, O, uType2} <: SciMLBase.AbstractNonlinearSolution{T, N}\n\nRepresentation of the solution to an nonlinear equation defined by an NonlinearProblem, or the steady state solution to a differential equation defined by a SteadyStateProblem.\n\nFields\n\nu: the representation of the nonlinear equation's solution.\nresid: the residual of the solution.\nprob: the original NonlinearProblem/SteadyStateProblem that was solved.\nalg: the algorithm type used by the solver.\noriginal: if the solver is wrapped from an alternative solver ecosystem, such as NLsolve.jl, then this is the original return from said solver library.\nretcode: the return code from the solver. Used to determine whether the solver solved successfully or whether it exited due to an error. For more details, see  the return code documentation.\nleft: if the solver is bracketing method, this is the final left bracket value.\nright: if the solver is bracketing method, this is the final right bracket value.\n\n\n\n\n\n","category":"type"},{"location":"solvers/SteadyStateSolvers/#Steady-State-Solvers","page":"Steady State Solvers","title":"Steady State Solvers","text":"","category":"section"},{"location":"solvers/SteadyStateSolvers/","page":"Steady State Solvers","title":"Steady State Solvers","text":"solve(prob::SteadyStateProblem,alg;kwargs)","category":"page"},{"location":"solvers/SteadyStateSolvers/","page":"Steady State Solvers","title":"Steady State Solvers","text":"Solves for the steady states in the problem defined by prob using the algorithm alg. If no algorithm is given, a default algorithm will be chosen.","category":"page"},{"location":"solvers/SteadyStateSolvers/#Recommended-Methods","page":"Steady State Solvers","title":"Recommended Methods","text":"","category":"section"},{"location":"solvers/SteadyStateSolvers/","page":"Steady State Solvers","title":"Steady State Solvers","text":"Conversion to a NonlinearProblem is generally the fastest method. However, this will not guarantee the preferred root, and thus if the preferred root is required, then it's recommended that one uses DynamicSS. For DynamicSS, in many cases an adaptive stiff solver, like a Rosenbrock or BDF method (Rodas5 or QNDF), is a good way to allow for very large time steps as the steady state approaches.","category":"page"},{"location":"solvers/SteadyStateSolvers/","page":"Steady State Solvers","title":"Steady State Solvers","text":"note: Note\nThe SteadyStateDiffEq.jl methods on a SteadyStateProblem respect the time definition in the nonlinear definition, i.e. u' = f(u,t) uses the correct values for t as the solution evolves. A conversion of a SteadyStateProblem to a NonlinearProblem replaces this with the nonlinear system u' = f(u,∞), and thus the direct SteadyStateProblem approach can give different answers (i.e. the correct unique fixed point) on ODEs with non-autonomous dynamics.","category":"page"},{"location":"solvers/SteadyStateSolvers/#Full-List-of-Methods","page":"Steady State Solvers","title":"Full List of Methods","text":"","category":"section"},{"location":"solvers/SteadyStateSolvers/#Conversion-to-NonlinearProblem","page":"Steady State Solvers","title":"Conversion to NonlinearProblem","text":"","category":"section"},{"location":"solvers/SteadyStateSolvers/","page":"Steady State Solvers","title":"Steady State Solvers","text":"Any SteadyStateProblem can be trivially converted to a NonlinearProblem via NonlinearProblem(prob::SteadyStateProblem). Using this appraoch, any of the solvers from the Nonlinear System Solvers page can be used.","category":"page"},{"location":"solvers/SteadyStateSolvers/#SteadyStateDiffEq.jl","page":"Steady State Solvers","title":"SteadyStateDiffEq.jl","text":"","category":"section"},{"location":"solvers/SteadyStateSolvers/","page":"Steady State Solvers","title":"Steady State Solvers","text":"SteadyStateDiffEq.jl uses ODE solvers to iteratively approach the steady state. It is a very stable method for solving nonlinear systems, though in many cases can be more computationally expensive than direct methods.","category":"page"},{"location":"solvers/SteadyStateSolvers/","page":"Steady State Solvers","title":"Steady State Solvers","text":"DynamicSS : Uses an ODE solver to find the steady state. Automatically terminates when close to the steady state. DynamicSS(alg;abstol=1e-8,reltol=1e-6,tspan=Inf) requires that an ODE algorithm is given as the first argument.  The absolute and relative tolerances specify the termination conditions on the derivative's closeness to zero.  This internally uses the TerminateSteadyState callback from the Callback Library.  The simulated time for which given ODE is solved can be limited by tspan.  If tspan is a number, it is equivalent to passing (zero(tspan), tspan).","category":"page"},{"location":"solvers/SteadyStateSolvers/","page":"Steady State Solvers","title":"Steady State Solvers","text":"Example usage:","category":"page"},{"location":"solvers/SteadyStateSolvers/","page":"Steady State Solvers","title":"Steady State Solvers","text":"using NonlinearSolve, SteadyStateDiffEq, OrdinaryDiffEq\nsol = solve(prob,DynamicSS(Tsit5()))\n\nusing Sundials\nsol = solve(prob,DynamicSS(CVODE_BDF()),dt=1.0)","category":"page"},{"location":"solvers/SteadyStateSolvers/","page":"Steady State Solvers","title":"Steady State Solvers","text":"note: Note\nIf you use CVODE_BDF you may need to give a starting dt via dt=.....*","category":"page"},{"location":"solvers/NonlinearSystemSolvers/#nonlinearsystemsolvers","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"","category":"section"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"solve(prob::NonlinearProblem,alg;kwargs)","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"Solves for f(u)=0 in the problem defined by prob using the algorithm alg. If no algorithm is given, a default algorithm will be chosen.","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"This page is solely focused on the methods for nonlinear systems.","category":"page"},{"location":"solvers/NonlinearSystemSolvers/#Recommended-Methods","page":"Nonlinear System Solvers","title":"Recommended Methods","text":"","category":"section"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"NewtonRaphson is a good choice for most problems.  For large systems it can make use of sparsity patterns for sparse automatic differentiation and sparse linear solving of very large systems. That said, as a classic Newton method, its stability region can be smaller than other methods. Meanwhile, SimpleNewtonRaphson is an implementation which is specialized for small equations. It is non-allocating on static arrays and thus really well-optimized for small systems, thus usually outperforming the other methods when such types are used for u0. NLSolveJL's :trust_region method can be a good choice for high stability, along with DynamicSS.","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"For a system which is very non-stiff (i.e., the condition number of the Jacobian is small, or the eigenvalues of the Jacobian are within a few orders of magnitude), then NLSolveJL's :anderson can be a good choice.","category":"page"},{"location":"solvers/NonlinearSystemSolvers/#Full-List-of-Methods","page":"Nonlinear System Solvers","title":"Full List of Methods","text":"","category":"section"},{"location":"solvers/NonlinearSystemSolvers/#NonlinearSolve.jl","page":"Nonlinear System Solvers","title":"NonlinearSolve.jl","text":"","category":"section"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"These are the core solvers.","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"NewtonRaphson(): A Newton-Raphson method with swappable nonlinear solvers and autodiff methods for high performance on large and sparse systems.","category":"page"},{"location":"solvers/NonlinearSystemSolvers/#Details-on-Controlling-NonlinearSolve.jl-Solvers","page":"Nonlinear System Solvers","title":"Details on Controlling NonlinearSolve.jl Solvers","text":"","category":"section"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"NewtonRaphson(; chunk_size = Val{0}(), autodiff = Val{true}(),\n                standardtag = Val{true}(), concrete_jac = nothing,\n                diff_type = Val{:forward}, linsolve = nothing, precs = DEFAULT_PRECS)","category":"page"},{"location":"solvers/NonlinearSystemSolvers/#SimpleNonlinearSolve.jl","page":"Nonlinear System Solvers","title":"SimpleNonlinearSolve.jl","text":"","category":"section"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"These methods are included with NonlinearSolve.jl by default, though SimpleNonlinearSolve.jl can be used directly to reduce dependencies and improve load times.","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"SimpleNewtonRaphson(): A simplified implementation of the Newton-Raphson method. Has the property that when used with states u as a Number or StaticArray, the solver is very efficient and non-allocating. Thus this implmentation is well-suited for small systems of equations.","category":"page"},{"location":"solvers/NonlinearSystemSolvers/#SteadyStateDiffEq.jl","page":"Nonlinear System Solvers","title":"SteadyStateDiffEq.jl","text":"","category":"section"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"Note that these solvers do not come by default, and thus one needs to install the package before using these solvers:","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"]add SteadyStateDiffEq\nusing SteadyStateDiffEq","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"SteadyStateDiffEq.jl uses ODE solvers to iteratively approach the steady state. It is a very stable method for solving nonlinear systems, though in many cases can be more computationally expensive than direct methods.","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"DynamicSS : Uses an ODE solver to find the steady state. Automatically terminates when close to the steady state. DynamicSS(alg;abstol=1e-8,reltol=1e-6,tspan=Inf) requires that an ODE algorithm is given as the first argument.  The absolute and relative tolerances specify the termination conditions on the derivative's closeness to zero.  This internally uses the TerminateSteadyState callback from the Callback Library.  The simulated time for which given ODE is solved can be limited by tspan.  If tspan is a number, it is equivalent to passing (zero(tspan), tspan).","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"Example usage:","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"using NonlinearSolve, SteadyStateDiffEq, OrdinaryDiffEq\nsol = solve(prob,DynamicSS(Tsit5()))\n\nusing Sundials\nsol = solve(prob,DynamicSS(CVODE_BDF()),dt=1.0)","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"note: Note\nIf you use CVODE_BDF you may need to give a starting dt via dt=.....*","category":"page"},{"location":"solvers/NonlinearSystemSolvers/#SciMLNLSolve.jl","page":"Nonlinear System Solvers","title":"SciMLNLSolve.jl","text":"","category":"section"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"This is a wrapper package for importing solvers from NLsolve.jl into this interface. Note that these solvers do not come by default, and thus one needs to install the package before using these solvers:","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"]add SciMLNLSolve\nusing SciMLNLSolve","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"NLSolveJL(): A wrapper for NLsolve.jl","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"NLSolveJL(;\n          method=:trust_region,\n          autodiff=:central,\n          store_trace=false,\n          extended_trace=false,\n          linesearch=LineSearches.Static(),\n          linsolve=(x, A, b) -> copyto!(x, A\\b),\n          factor = one(Float64),\n          autoscale=true,\n          m=10,\n          beta=one(Float64),\n          show_trace=false,\n       )","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"Choices for methods in NLSolveJL:","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":":fixedpoint: Fixed-point iteration\n:anderson: Anderson-accelerated fixed-point iteration\n:newton: Classical Newton method with an optional line search\n:trust_region: Trust region Newton method (the default choice)","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"For more information on these arguments, consult the NLsolve.jl documentation.","category":"page"},{"location":"solvers/NonlinearSystemSolvers/#Sundials.jl","page":"Nonlinear System Solvers","title":"Sundials.jl","text":"","category":"section"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"This is a wrapper package for the SUNDIALS C library, specifically the KINSOL nonlinear solver included in that ecosystem. Note that these solvers do not come by default, and thus one needs to install the package before using these solvers:","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"]add Sundials\nusing Sundials","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"KINSOL: The KINSOL method of the SUNDIALS C library","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"KINSOL(;\n    linear_solver = :Dense,\n    jac_upper = 0,\n    jac_lower = 0,\n    userdata = nothing,\n)","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"The choices for the linear solver are:","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":":Dense: A dense linear solver\n:Band: A solver specialized for banded Jacobians. If used, you must set the position of the upper and lower non-zero diagonals via jac_upper and jac_lower.\n:LapackDense: A version of the dense linear solver that uses the Julia-provided OpenBLAS-linked LAPACK for multithreaded operations. This will be faster than :Dense on larger systems but has noticeable overhead on smaller (<100 ODE) systems.\n:LapackBand: A version of the banded linear solver that uses the Julia-provided OpenBLAS-linked LAPACK for multithreaded operations. This will be faster than :Band on larger systems but has noticeable overhead on smaller (<100 ODE) systems.\n:Diagonal: This method is specialized for diagonal Jacobians.\n:GMRES: A GMRES method. Recommended first choice Krylov method.\n:BCG: A biconjugate gradient method\n:PCG: A preconditioned conjugate gradient method. Only for symmetric linear systems.\n:TFQMR: A TFQMR method.\n:KLU: A sparse factorization method. Requires that the user specify a Jacobian. The Jacobian must be set as a sparse matrix in the ODEProblem type.","category":"page"},{"location":"solvers/NonlinearSystemSolvers/#NonlinearSolveMINPACK","page":"Nonlinear System Solvers","title":"NonlinearSolveMINPACK","text":"","category":"section"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"This is a wrapper package for importing solvers from MINPACK.jl into this interface. Note that these solvers do not come by default, and thus one needs to install the package before using these solvers:","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"]add NonlinearSolveMINPACK\nusing NonlinearSolveMINPACK","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"CMINPACK(): A wrapper for using the classic MINPACK method through MINPACK.jl","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"CMINPACK(;show_trace::Bool=false, tracing::Bool=false, method::Symbol=:hybr,\n          io::IO=stdout)","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"The keyword argument method can take on different value depending on which method of fsolve you are calling. The standard choices of method are:","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":":hybr: Modified version of Powell's algorithm. Uses MINPACK routine hybrd1\n:lm: Levenberg-Marquardt. Uses MINPACK routine lmdif1\n:lmdif: Advanced Levenberg-Marquardt (more options available with ;kwargs...). See MINPACK routine lmdif for more information\n:hybrd: Advacned modified version of Powell's algorithm (more options available with ;kwargs...). See MINPACK routine hybrd for more information","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":"If a Jacobian is supplied as part of the NonlinearFunction, then the following methods are allowed:","category":"page"},{"location":"solvers/NonlinearSystemSolvers/","page":"Nonlinear System Solvers","title":"Nonlinear System Solvers","text":":hybr: Advacned modified version of Powell's algorithm with user supplied Jacobian. Additional arguments are available via ;kwargs.... See MINPACK routine hybrj for more information\n:lm: Advanced Levenberg-Marquardt with user supplied Jacobian. Additional arguments are available via ;kwargs.... See MINPACK routine lmder for more information","category":"page"},{"location":"tutorials/nonlinear/#Solving-Nonlinear-Systems","page":"Solving Nonlinear Systems","title":"Solving Nonlinear Systems","text":"","category":"section"},{"location":"tutorials/nonlinear/","page":"Solving Nonlinear Systems","title":"Solving Nonlinear Systems","text":"A nonlinear system f(u) = 0 is specified by defining a function f(u,p), where p are the parameters of the system. For example, the following solves the vector equation f(u) = u^2 - p for a vector of equations:","category":"page"},{"location":"tutorials/nonlinear/","page":"Solving Nonlinear Systems","title":"Solving Nonlinear Systems","text":"using NonlinearSolve, StaticArrays\n\nf(u,p) = u .* u .- p\nu0 = @SVector[1.0, 1.0]\np = 2.0\nprobN = NonlinearProblem{false}(f, u0, p)\nsolver = solve(probN, NewtonRaphson(), reltol = 1e-9)","category":"page"},{"location":"tutorials/nonlinear/","page":"Solving Nonlinear Systems","title":"Solving Nonlinear Systems","text":"where u0 is the initial condition for the rootfind. Native NonlinearSolve.jl solvers use the given type of u0 to determine the type used within the solver and the return. Note that the parameters p can be any type, but most are an AbstractArray for automatic differentiation.","category":"page"},{"location":"tutorials/nonlinear/#Using-Bracketing-Methods","page":"Solving Nonlinear Systems","title":"Using Bracketing Methods","text":"","category":"section"},{"location":"tutorials/nonlinear/","page":"Solving Nonlinear Systems","title":"Solving Nonlinear Systems","text":"For scalar rootfinding problems, bracketing methods exist. In this case, one passes a bracket instead of an initial condition, for example:","category":"page"},{"location":"tutorials/nonlinear/","page":"Solving Nonlinear Systems","title":"Solving Nonlinear Systems","text":"using NonlinearSolve\nf(u, p) = u*u - 2.0\nuspan = (1.0, 2.0) # brackets\nprobB = IntervalNonlinearProblem(f, uspan)\nsol = solve(probB, Falsi())","category":"page"},{"location":"tutorials/iterator_interface/#Nonlinear-Solver-Iterator-Interface","page":"Nonlinear Solver Iterator Interface","title":"Nonlinear Solver Iterator Interface","text":"","category":"section"},{"location":"tutorials/iterator_interface/","page":"Nonlinear Solver Iterator Interface","title":"Nonlinear Solver Iterator Interface","text":"There is an iterator form of the nonlinear solver which mirrors the DiffEq integrator interface:","category":"page"},{"location":"tutorials/iterator_interface/","page":"Nonlinear Solver Iterator Interface","title":"Nonlinear Solver Iterator Interface","text":"using NonlinearSolve\nf(u, p) = u .* u .- 2.0\nu0 = 1.5\nprobB = NonlinearProblem(f, u0)\ncache = init(probB, NewtonRaphson()) # Can iterate the solver object\nsolver = solve!(cache)","category":"page"},{"location":"basics/FAQ/#Frequently-Asked-Questions","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"basics/FAQ/#How-is-the-performance-of-Julia's-NonlinearSolve.jl-vs-MATLAB's-fzero?","page":"Frequently Asked Questions","title":"How is the performance of Julia's NonlinearSolve.jl vs MATLAB's fzero?","text":"","category":"section"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"This is addressed in a Twitter thread with the author of the improved fzero. On the test example:","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"using NonlinearSolve, BenchmarkTools\n\nN = 100_000;\nlevels = 1.5 .* rand(N);\nout = zeros(N);\nmyfun(x, lv) = x * sin(x) - lv\n\nfunction f(out, levels, u0)\n    for i in 1:N\n        out[i] = solve(IntervalNonlinearProblem{false}(IntervalNonlinearFunction{false}(myfun),\n                u0, levels[i]), Falsi()).u\n    end\nend\n\nfunction f2(out, levels, u0)\n    for i in 1:N\n        out[i] = solve(NonlinearProblem{false}(NonlinearFunction{false}(myfun),\n                u0, levels[i]), SimpleNewtonRaphson()).u\n    end\nend\n\n@btime f(out, levels, (0.0, 2.0))\n@btime f2(out, levels, 1.0)","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"MATLAB 2022a achieves 1.66s. Try this code yourself: we receive 0.06 seconds, or a 28x speedup. This example is still not optimized in the Julia code and we expect an improvement in a near future version.","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"For more information on performance of SciML, see the SciMLBenchmarks.","category":"page"},{"location":"#NonlinearSolve.jl:-High-Performance-Unified-Nonlinear-Solvers","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"","category":"section"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"NonlinearSolve.jl is a unified interface for the nonlinear solving packages of Julia. It includes its own high-performance nonlinear solvers which include the ability to swap out to fast direct and iterative linear solvers, along with the ability to use sparse automatic differentiation for Jacobian construction and Jacobian-vector products. It interfaces with other packages of the Julia ecosystem to make it easy to test alternative solver packages and pass small types to control algorithm swapping. It also interfaces with the ModelingToolkit.jl world of symbolic modeling to allow for automatically generating high-performance code.","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"Performance is key: the current methods are made to be highly performant on scalar and statically sized small problems, with options for large-scale systems. If you run into any performance issues, please file an issue. Consult the NonlinearSystemSolvers page for information on how to import solvers from different packages.","category":"page"},{"location":"#Installation","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"Installation","text":"","category":"section"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"To install NonlinearSolve.jl, use the Julia package manager:","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"using Pkg\nPkg.add(\"NonlinearSolve\")","category":"page"},{"location":"#Contributing","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"Contributing","text":"","category":"section"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nOn the Julia Discourse forums\nSee also SciML Community page","category":"page"},{"location":"#Roadmap","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"Roadmap","text":"","category":"section"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"The current algorithms should support automatic differentiation, though improved adjoint overloads are planned to be added in the current update (which will make use of the f(u,p) form). Future updates will include standard methods for larger scale nonlinear solving like Newton-Krylov methods.","category":"page"},{"location":"#Reproducibility","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"</details>","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"</details>","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"using Pkg # hide\nPkg.status(;mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"</details>","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"You can also download the\n<a href=\"","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"using TOML\nversion = TOML.parse(read(\"../../Project.toml\",String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\",String))[\"name\"]\nlink = \"https://github.com/SciML/\"*name*\".jl/tree/gh-pages/v\"*version*\"/assets/Manifest.toml\"","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"\">manifest</a> file and the\n<a href=\"","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"using TOML\nversion = TOML.parse(read(\"../../Project.toml\",String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\",String))[\"name\"]\nlink = \"https://github.com/SciML/\"*name*\".jl/tree/gh-pages/v\"*version*\"/assets/Project.toml\"","category":"page"},{"location":"","page":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"\">project</a> file.","category":"page"},{"location":"basics/NonlinearFunctions/#nonlinearfunctions","page":"NonlinearFunctions and Jacobian Types","title":"NonlinearFunctions and Jacobian Types","text":"","category":"section"},{"location":"basics/NonlinearFunctions/","page":"NonlinearFunctions and Jacobian Types","title":"NonlinearFunctions and Jacobian Types","text":"The SciML ecosystem provides an extensive interface for declaring extra functions associated with the differential equation's data. In traditional libraries there is usually only one option: the Jacobian. However, we allow for a large array of pre-computed functions to speed up the calculations. This is offered via the NonlinearFunction types, which can be passed to the problems.","category":"page"},{"location":"basics/NonlinearFunctions/#Function-Type-Definitions","page":"NonlinearFunctions and Jacobian Types","title":"Function Type Definitions","text":"","category":"section"},{"location":"basics/NonlinearFunctions/","page":"NonlinearFunctions and Jacobian Types","title":"NonlinearFunctions and Jacobian Types","text":"SciMLBase.IntervalNonlinearFunction\nSciMLBase.NonlinearFunction","category":"page"},{"location":"basics/NonlinearFunctions/#SciMLBase.IntervalNonlinearFunction","page":"NonlinearFunctions and Jacobian Types","title":"SciMLBase.IntervalNonlinearFunction","text":"IntervalNonlinearFunction{iip, specialize, F, Ta, S, S2, O, SYS} <: AbstractIntervalNonlinearFunction{iip,specialize}\n\nA representation of an interval nonlinear system of equations f, defined by:\n\nf(tp) = u = 0\n\nand all of its related functions. For all cases, p are the parameters and t is the interval variable.\n\nConstructor\n\nIntervalNonlinearFunction{iip, specialize}(f;\n                           analytic = __has_analytic(f) ? f.analytic : nothing,\n                           syms = __has_syms(f) ? f.syms : nothing,\n                           paramsyms = __has_paramsyms(f) ? f.paramsyms : nothing,\n                           sys = __has_sys(f) ? f.sys : nothing)\n\nNote that only the function f itself is required. This function should be given as f!(u,t,p) or u = f(t,p). See the section on iip for more details on in-place vs out-of-place handling.\n\nAll of the remaining functions are optional for improving or accelerating the usage of f. These include:\n\nanalytic(p): used to pass an analytical solution function for the analytical solution of the ODE. Generally only used for testing and development of the solvers.\nsyms: the symbol names for the elements of the equation. This should match u0 in size. For example, if u0 = [0.0,1.0] and syms = [:x, :y], this will apply a canonical naming to the values, allowing sol[:x] in the solution and automatically naming values in plots.\nparamsyms: the symbol names for the parameters of the equation. This should match p in size. For example, if p = [0.0, 1.0] and paramsyms = [:a, :b], this will apply a canonical naming to the values, allowing sol[:a] in the solution.\n\niip: In-Place vs Out-Of-Place\n\nFor more details on this argument, see the ODEFunction documentation.\n\nspecialize: Controlling Compilation and Specialization\n\nFor more details on this argument, see the ODEFunction documentation.\n\nFields\n\nThe fields of the IntervalNonlinearFunction type directly match the names of the inputs.\n\n\n\n","category":"type"},{"location":"basics/NonlinearFunctions/#SciMLBase.NonlinearFunction","page":"NonlinearFunctions and Jacobian Types","title":"SciMLBase.NonlinearFunction","text":"NonlinearFunction{iip,F,TMM,Ta,Tt,TJ,JVP,VJP,JP,SP,TW,TWt,TPJ,S,S2,O,TCV} <: AbstractNonlinearFunction{iip,specialize}\n\nA representation of an nonlinear system of equations f, defined by:\n\n0 = f(up)\n\nand all of its related functions, such as the Jacobian of f, its gradient with respect to time, and more. For all cases, u0 is the initial condition, p are the parameters, and t is the independent variable.\n\nConstructor\n\nNonlinearFunction{iip, specialize}(f;\n                           analytic = __has_analytic(f) ? f.analytic : nothing,\n                           jac = __has_jac(f) ? f.jac : nothing,\n                           jvp = __has_jvp(f) ? f.jvp : nothing,\n                           vjp = __has_vjp(f) ? f.vjp : nothing,\n                           jac_prototype = __has_jac_prototype(f) ? f.jac_prototype : nothing,\n                           sparsity = __has_sparsity(f) ? f.sparsity : jac_prototype,\n                           paramjac = __has_paramjac(f) ? f.paramjac : nothing,\n                           syms = __has_syms(f) ? f.syms : nothing,\n                           paramsyms = __has_paramsyms(f) ? f.paramsyms : nothing,\n                           colorvec = __has_colorvec(f) ? f.colorvec : nothing,\n                           sys = __has_sys(f) ? f.sys : nothing)\n\nNote that only the function f itself is required. This function should be given as f!(du,u,p) or du = f(u,p). See the section on iip for more details on in-place vs out-of-place handling.\n\nAll of the remaining functions are optional for improving or accelerating the usage of f. These include:\n\nanalytic(u0,p): used to pass an analytical solution function for the analytical solution of the ODE. Generally only used for testing and development of the solvers.\njac(J,u,p) or J=jac(u,p): returns fracdfdu\njvp(Jv,v,u,p) or Jv=jvp(v,u,p): returns the directional derivativefracdfdu v\nvjp(Jv,v,u,p) or Jv=vjp(v,u,p): returns the adjoint derivativefracdfdu^ast v\njac_prototype: a prototype matrix matching the type that matches the Jacobian. For example, if the Jacobian is tridiagonal, then an appropriately sized Tridiagonal matrix can be used as the prototype and integrators will specialize on this structure where possible. Non-structured sparsity patterns should use a SparseMatrixCSC with a correct sparsity pattern for the Jacobian. The default is nothing, which means a dense Jacobian.\nparamjac(pJ,u,p): returns the parameter Jacobian fracdfdp.\nsyms: the symbol names for the elements of the equation. This should match u0 in size. For example, if u0 = [0.0,1.0] and syms = [:x, :y], this will apply a canonical naming to the values, allowing sol[:x] in the solution and automatically naming values in plots.\nparamsyms: the symbol names for the parameters of the equation. This should match p in size. For example, if p = [0.0, 1.0] and paramsyms = [:a, :b], this will apply a canonical naming to the values, allowing sol[:a] in the solution.\ncolorvec: a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the jac_prototype. This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern. Defaults to nothing, which means a color vector will be internally computed on demand when required. The cost of this operation is highly dependent on the sparsity pattern.\n\niip: In-Place vs Out-Of-Place\n\nFor more details on this argument, see the ODEFunction documentation.\n\nspecialize: Controlling Compilation and Specialization\n\nFor more details on this argument, see the ODEFunction documentation.\n\nFields\n\nThe fields of the NonlinearFunction type directly match the names of the inputs.\n\n\n\n","category":"type"},{"location":"solvers/BracketingSolvers/#Interval-Rootfinding-Methods-(Bracketing-Solvers)","page":"Interval Rootfinding Methods (Bracketing Solvers)","title":"Interval Rootfinding Methods (Bracketing Solvers)","text":"","category":"section"},{"location":"solvers/BracketingSolvers/","page":"Interval Rootfinding Methods (Bracketing Solvers)","title":"Interval Rootfinding Methods (Bracketing Solvers)","text":"solve(prob::IntervalNonlinearProblem,alg;kwargs)","category":"page"},{"location":"solvers/BracketingSolvers/","page":"Interval Rootfinding Methods (Bracketing Solvers)","title":"Interval Rootfinding Methods (Bracketing Solvers)","text":"Solves for f(t)=0 in the problem defined by prob using the algorithm alg. If no algorithm is given, a default algorithm will be chosen.","category":"page"},{"location":"solvers/BracketingSolvers/","page":"Interval Rootfinding Methods (Bracketing Solvers)","title":"Interval Rootfinding Methods (Bracketing Solvers)","text":"This page is solely focused on the bracketing methods for scalar nonlinear equations.","category":"page"},{"location":"solvers/BracketingSolvers/#Recommended-Methods","page":"Interval Rootfinding Methods (Bracketing Solvers)","title":"Recommended Methods","text":"","category":"section"},{"location":"solvers/BracketingSolvers/","page":"Interval Rootfinding Methods (Bracketing Solvers)","title":"Interval Rootfinding Methods (Bracketing Solvers)","text":"Falsi() can have a faster convergence and is discretely differentiable, but is less stable than Bisection.","category":"page"},{"location":"solvers/BracketingSolvers/#Full-List-of-Methods","page":"Interval Rootfinding Methods (Bracketing Solvers)","title":"Full List of Methods","text":"","category":"section"},{"location":"solvers/BracketingSolvers/#SimpleNonlinearSolve.jl","page":"Interval Rootfinding Methods (Bracketing Solvers)","title":"SimpleNonlinearSolve.jl","text":"","category":"section"},{"location":"solvers/BracketingSolvers/","page":"Interval Rootfinding Methods (Bracketing Solvers)","title":"Interval Rootfinding Methods (Bracketing Solvers)","text":"These methods are automatically included as part of NonlinearSolve.jl. Though one can use SimpleNonlinearSolve.jl directly to decrease the dependencies and improve load time.","category":"page"},{"location":"solvers/BracketingSolvers/","page":"Interval Rootfinding Methods (Bracketing Solvers)","title":"Interval Rootfinding Methods (Bracketing Solvers)","text":"Falsi: A non-allocating regula falsi method\nBisection: A common bisection method","category":"page"}]
}
